<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
	xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" targetNamespace="urn-com-amalto-xtentis-webservice"
	xmlns:tns="urn-com-amalto-xtentis-webservice" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xsi:schemaLocation="http://schemas.xmlsoap.org/wsdl/ http://schemas.xmlsoap.org/wsdl/"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

	<types xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn-com-amalto-xtentis-webservice"> 
	  <xsd:schema elementFormDefault="unqualified" targetNamespace="urn-com-amalto-xtentis-webservice">  
	    <!-- ***************************************************** GENERIC ELEMENTS 
	                ******************************************************* -->  
	    <xsd:element name="WSString"> 
	      <xsd:complexType> 
	        <xsd:sequence> 
	          <xsd:element maxOccurs="1" minOccurs="1" name="value" type="xsd:string"/> 
	        </xsd:sequence> 
	      </xsd:complexType> 
	    </xsd:element>  
	    <xsd:complexType name="WSStringArray"> 
	      <xsd:documentation>An array of string</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="strings" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSStringArray" type="tns:WSStringArray"/>  
	    <xsd:complexType name="WSByteArray"> 
	      <xsd:documentation>An array of bytes</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="bytes" nillable="true" type="xsd:base64Binary"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSByteArray" type="tns:WSByteArray"/>  
	    <xsd:complexType name="WSInt"> 
	      <xsd:documentation>A return message containing a single Integer</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="value" type="xsd:int"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSInt" type="tns:WSInt"/>  
	    <xsd:complexType name="WSI18nString"> 
	      <xsd:documentation>An internationalized/localized String -language: the ISO lanaguage code -label: the localized label value</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="language" type="tns:WSLanguage"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="label" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:complexType name="WSBoolean"> 
	      <xsd:documentation>A return message containing a single boolean (true/false)</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBoolean" type="tns:WSBoolean"/>  
	    <xsd:simpleType name="WSLanguage"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="FR"/>  
	        <xsd:enumeration value="EN"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:simpleType name="WSBaseType"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="string"/>  
	        <xsd:enumeration value="int"/>  
	        <xsd:enumeration value="token"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSKey"> 
	      <xsd:annotation> 
	        <xsd:documentation>In simple terms: each key field is found using the path selectorpath/fieldpath within the element</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="selectorpath" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="fieldpath" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:complexType name="WSLinkedHashMap"> 
	      <xsd:annotation> 
	        <xsd:documentation>A generic implementation of a linked hash map</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="typedContentEntry" nillable="true"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="key" nillable="true" type="xsd:string"/>  
	              <xsd:element maxOccurs="1" minOccurs="1" name="value" nillable="true" type="tns:WSStringArray"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSLinkedHashMap" type="tns:WSLinkedHashMap"/>  
	    <xsd:complexType name="WSTypedContent"> 
	      <xsd:documentation>A return message containing and array of bytes or an URL pointing to data and the content-type of the data url: an url pointing to data (e.g. http://www.mysite.com/data/MyData or file://var/data/myData) wsBytes: an array of bytes. url should be nil or non present when used. contentType: the content type (e.g. 'application/pdf' or 'text/xml; charset=utf-8')</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="0" name="url" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="wsBytes" nillable="true" type="tns:WSByteArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="contentType" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTypedContent" type="tns:WSTypedContent"/>  
	    <xsd:complexType name="WSTypedContentMap"> 
	      <xsd:documentation>An implementation of an HashMap of TypedCOntent - see WSTypedContent</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="mapEntry"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="key" nillable="false" type="xsd:string"/>  
	              <xsd:element maxOccurs="1" minOccurs="1" name="typedContent" nillable="false" type="tns:WSTypedContent"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTypedContentMap" type="tns:WSTypedContentMap"/>  
	    <xsd:complexType name="WSConceptRevisionMap"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="mapEntry"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="concept" nillable="false" type="xsd:string"/>  
	              <xsd:element maxOccurs="1" minOccurs="1" name="revision" nillable="false" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSConceptRevisionMap" type="tns:WSConceptRevisionMap"/>  
	    <!-- ***************************************************** MANAGEMENT 
	                ******************************************************* -->  
	    <xsd:simpleType name="WSComponent"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="DataManager"/>  
	        <xsd:enumeration value="Service"/>  
	        <xsd:enumeration value="Connector"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSGetComponentVersion"> 
	      <xsd:documentation>A message to retrieve the version of a component component: the type of component -see WSComponent id: the id of the component; its JNDI name for services and connectors</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="component" nillable="false" type="tns:WSComponent"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="id" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetComponentVersion" type="tns:WSGetComponentVersion"/>  
	    <xsd:complexType name="WSVersion"> 
	      <xsd:documentation>A return message containing the version of the component - see WSGetComponentVersion</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="major" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="minor" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="revision" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="build" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="date" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSVersion" type="tns:WSVersion"/>  
	    <xsd:complexType name="WSPing"> 
	      <xsd:documentation>A message to ping an MDM server and see if it is up and running</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="echo" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPing" type="tns:WSPing"/>  
	    <xsd:complexType name="WSRefreshCache"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="type" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRefreshCache" type="tns:WSRefreshCache"/>  
	    <xsd:complexType name="WSLogout"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="0" name="dummy" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSLogout" type="tns:WSLogout"/>  
	    <!-- ***************************************************** INITIALIZATION 
	                ******************************************************* -->  
	    <xsd:complexType name="WSInitData"> 
	      <xsd:documentation>DEPRECATED A message to automatically initialize the MDM server</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="zap" nillable="false" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xmlSchema" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSInitData" type="tns:WSInitData"/>  
	    <xsd:complexType name="WSDocumentPK"> 
	      <xsd:documentation>DEPRECATED The primary key of a document - kept for calls compatibility; always null in calls</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDocumentPK" type="tns:WSDocumentPK"/>  
	    <!-- ***************************************************** D A T A M O 
	                D E L ******************************************************* -->  
	    <xsd:complexType name="WSDataModel"> 
	      <xsd:annotation> 
	        <xsd:documentation>A Data Model core object. name: the unique name of the data model description: the description of the data model xsdSchema: the XSD schema for this data model</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xsdSchema" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataModel" type="tns:WSDataModel"/>  
	    <xsd:complexType name="WSDataModelPK"> 
	      <xsd:documentation>The Primary key of a Data Model: its name</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataModelPK" type="tns:WSDataModelPK"/>  
	    <xsd:complexType name="WSDataModelArray"> 
	      <xsd:documentation>An array of Data Models - see WSDataModel</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsDataModels" nillable="false" type="tns:WSDataModel"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataModelArray" type="tns:WSDataModelArray"/>  
	    <xsd:complexType name="WSDataModelPKArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsDataModelPKs" nillable="false" type="tns:WSDataModelPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataModelPKArray" type="tns:WSDataModelPKArray"/>  
	    <xsd:complexType name="WSBusinessConcept"> 
	      <xsd:annotation> 
	        <xsd:documentation>Can be used as a simple alternative to avoid loading a schema xsd:element @see putBusinessConceptSchema xsd types can be used as business template</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="businessTemplate" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsUniqueKey" nillable="false" type="tns:WSKey"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsLabel" nillable="false" type="tns:WSI18nString"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsDescription" nillable="false" type="tns:WSI18nString"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessConcept" type="tns:WSBusinessConcept"/>  
	    <xsd:simpleType name="WSTemplateType"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="SIMPLE"/>  
	        <xsd:enumeration value="COMPLEX"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSBusinessTemplate"> 
	      <xsd:annotation> 
	        <xsd:documentation>Can be used as a simple alternative to avoid loading a schema xsd:simpleType or xsd:complexType Element @see putBusinessTemplateSchema one of simpletemplate or complextemplate must be filled in accordance with type</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="type" nillable="false" type="tns:WSTemplateType"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="simpleTemplate" nillable="false" type="tns:WSBusinessSimpleTemplate"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="complexTemplate" nillable="false" type="tns:WSBusinessComplexTemplate"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessTemplate" type="tns:WSBusinessTemplate"/>  
	    <xsd:complexType name="WSBusinessSimpleTemplate"> 
	      <xsd:annotation> 
	        <xsd:documentation>Can be used as a simple alternative to avoid loading a schema xsd:simpleType Element @see putBusinessTemplateSchema xsd types MUST be used as xsdbasetype</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xsdBaseType" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="pattern" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessSimpleTemplate" type="tns:WSBusinessSimpleTemplate"/>  
	    <xsd:complexType name="WSBusinessComplexTemplate"> 
	      <xsd:documentation>The description of a complex type within a data model</xsd:documentation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsBusinessElements" nillable="false" type="tns:WSBusinessElement"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessComplexTemplate" type="tns:WSBusinessComplexTemplate"/>  
	    <xsd:complexType name="WSBusinessElement"> 
	      <xsd:annotation> 
	        <xsd:documentation>A "sub-element" in a Complex Template xsd types can be used as business template</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="minOccurs" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxOccurs" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="businessTemplate" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="wsForeignKey" nillable="false" type="tns:WSKey"/>  
	        <!-- ignored in this release -->  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsLabel" nillable="false" type="tns:WSI18nString"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsDescription" nillable="false" type="tns:WSI18nString"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessElement" type="tns:WSBusinessElement"/>  
	    <!-- Operations -->  
	    <xsd:complexType name="WSPutDataModel"> 
	      <xsd:annotation> 
	        <xsd:documentation>Create - updates a data model</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModel" nillable="false" type="tns:WSDataModel"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutDataModel" type="tns:WSPutDataModel"/>  
	    <xsd:complexType name="WSGetDataModel"> 
	      <xsd:documentation>A message to retrieve a data model. A SOAP Exception is thrown if the data model is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetDataModel" type="tns:WSGetDataModel"/>  
	    <xsd:complexType name="WSExistsDataModel"> 
	      <xsd:documentation>A message to retrieve a data model. No Exception is thrown if the data model is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsDataModel" type="tns:WSExistsDataModel"/>  
	    <xsd:complexType name="WSDeleteDataModel"> 
	      <xsd:documentation>A message to delete a Data Model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteDataModel" type="tns:WSDeleteDataModel"/>  
	    <!-- <xsd:complexType name="WSRegexDataModels"> <xsd:annotation> <xsd:documentation> 
	                Get a list of data models using a regular expression </xsd:documentation> 
	                </xsd:annotation> <xsd:sequence> <xsd:element minOccurs="1" maxOccurs="1" 
	                nillable="false" name="regex" type="xsd:string"/> </xsd:sequence> </xsd:complexType> 
	                <xsd:element name="WSRegexDataModels" type="tns:WSRegexDataModels"/> -->  
	    <xsd:complexType name="WSRegexDataModelPKs"> 
	      <xsd:annotation> 
	        <xsd:documentation>Get a list of data model PKs using a regular expression</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRegexDataModelPKs" type="tns:WSRegexDataModelPKs"/>  
	    <xsd:complexType name="WSCheckSchema"> 
	      <xsd:annotation> 
	        <xsd:documentation>Check is a schema is valid</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="schema" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCheckSchema" type="tns:WSCheckSchema"/>  
	    <xsd:complexType name="WSPutBusinessConcept"> 
	      <xsd:documentation>A message to create/overwrite a concept in an existing data model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="businessConcept" nillable="false" type="tns:WSBusinessConcept"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutBusinessConcept" type="tns:WSPutBusinessConcept"/>  
	    <xsd:complexType name="WSPutBusinessConceptSchema"> 
	      <xsd:documentation>A message to create/overwrite a generic type in an existing data model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="businessConceptSchema" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutBusinessConceptSchema" type="tns:WSPutBusinessConceptSchema"/>  
	    <xsd:complexType name="WSDeleteBusinessConcept"> 
	      <xsd:documentation>A message to delete an existing cncept in an existing data model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="businessConceptName" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteBusinessConcept" type="tns:WSDeleteBusinessConcept"/>  
	    <xsd:complexType name="WSGetBusinessConcepts"> 
	      <xsd:documentation>A message to retrieve the list of all concepts in a data model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetBusinessConcepts" type="tns:WSGetBusinessConcepts"/>  
	    <xsd:complexType name="WSGetBusinessConceptKey"> 
	      <xsd:documentation>A message to retrieve the XSD Key structure (see WSConceptKey) of a concept in data model</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="concept" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetBusinessConceptKey" type="tns:WSGetBusinessConceptKey"/>  
	    <xsd:complexType name="WSConceptKey"> 
	      <xsd:documentation>The XSD key structure of a concept in a data model (see WSGetBusinessConceptKey)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="selector" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="fields" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSConceptKey" type="tns:WSConceptKey"/>  
	    <!-- ***************************************************** D A T A C L 
	                U S T E R ******************************************************* -->  
	    <xsd:simpleType name="WSDataClusterType"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="CACHE"/>  
	        <xsd:enumeration value="ITEMS"/>  
	        <xsd:enumeration value="UNKNOWN"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSDataCluster"> 
	      <xsd:annotation> 
	        <xsd:documentation>A data cluster. Stemming is only supported with the Xyleme server and is not recommended. Use the value 100 to disable stemming. The speller refresh period is ignored at this stage. A value of -1 disables spell checking entirely in the cluster. Vocabulary holds the stemmer vocabulary. It should have an empty value on creation.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="vocabulary" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataCluster" type="tns:WSDataCluster"/>  
	    <xsd:complexType name="WSDataClusterPK"> 
	      <xsd:documentation>The primary key of a data cluster (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataClusterPK" type="tns:WSDataClusterPK"/>  
	    <xsd:complexType name="WSDataClusterArray"> 
	      <xsd:documentation>An array of data cluster instances</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsDataClusters" nillable="false" type="tns:WSDataCluster"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataClusterArray" type="tns:WSDataClusterArray"/>  
	    <xsd:complexType name="WSDataClusterPKArray"> 
	      <xsd:documentation>An array of data cluster primary keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsDataClusterPKs" nillable="false" type="tns:WSDataClusterPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDataClusterPKArray" type="tns:WSDataClusterPKArray"/>  
	    <!-- Operations -->  
	    <xsd:complexType name="WSPutDBDataCluster"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutDBDataCluster" type="tns:WSPutDBDataCluster"/>  
	    <xsd:complexType name="WSPutDataCluster"> 
	      <xsd:annotation> 
	        <xsd:documentation>Create a data-cluster. Characteristics (stemming, etc...) of a data cluster cannot be changed</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataCluster" nillable="false" type="tns:WSDataCluster"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutDataCluster" type="tns:WSPutDataCluster"/>  
	    <xsd:complexType name="WSGetDataCluster"> 
	      <xsd:documentation>A message to retrieve a data cluster Will throw a SOAP exception if the data cluster is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetDataCluster" type="tns:WSGetDataCluster"/>  
	    <xsd:complexType name="WSExistsDataCluster"> 
	      <xsd:documentation>A message to retrieve a data cluster Will return null if the data cluster is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsDataCluster" type="tns:WSExistsDataCluster"/>  
	    <xsd:complexType name="WSExistsDBDataCluster"> 
	      <xsd:documentation>A message to retrieve a DB (?) data cluster Will throw a SOAP exception if the data cluster is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsDBDataCluster" type="tns:WSExistsDBDataCluster"/>  
	    <xsd:complexType name="WSDeleteDataCluster"> 
	      <xsd:documentation>A message to delete a data cluster</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteDataCluster" type="tns:WSDeleteDataCluster"/>  
	    <xsd:complexType name="WSRegexDataClusterPKs"> 
	      <xsd:annotation> 
	        <xsd:documentation>A list of Data Custer PKs obtained using a regex. Pass * to retrieve all of them.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRegexDataClusterPKs" type="tns:WSRegexDataClusterPKs"/>  
	    <xsd:complexType name="WSGetConceptsInDataCluster"> 
	      <xsd:documentation>A message to retrieve the list of concepts actually stored in a Data Cluster</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetConceptsInDataCluster" type="tns:WSGetConceptsInDataCluster"/>  
	    <!-- ***************************************************** W H E R E E 
	                L E M E N T S used by Views and Searches ******************************************************* -->  
	    <xsd:complexType name="WSWhereCondition"> 
	      <xsd:annotation> 
	        <xsd:documentation>Use this object to write where conditions.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="0" name="leftPath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="operator" nillable="true" type="tns:WSWhereOperator"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="rightValueOrPath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="stringPredicate" nillable="true" type="tns:WSStringPredicate"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellCheck" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:simpleType name="WSWhereOperator"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="JOIN"/>  
	        <xsd:enumeration value="CONTAINS_TEXT_OF"/>  
	        <xsd:enumeration value="CONTAINS"/>  
	        <xsd:enumeration value="STARTSWITH"/>  
	        <xsd:enumeration value="STRICTCONTAINS"/>  
	        <xsd:enumeration value="EQUALS"/>  
	        <xsd:enumeration value="NOT_EQUALS"/>  
	        <xsd:enumeration value="GREATER_THAN"/>  
	        <xsd:enumeration value="GREATER_THAN_OR_EQUAL"/>  
	        <xsd:enumeration value="LOWER_THAN"/>  
	        <xsd:enumeration value="LOWER_THAN_OR_EQUAL"/>  
	        <xsd:enumeration value="NO_OPERATOR"/>  
	        <xsd:enumeration value="FULLTEXTSEARCH"/>  
	        <xsd:enumeration value="EMPTY_NULL"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:simpleType name="WSStringPredicate"> 
	      <!-- for CONTAINS and STRICTCONTAINS ONLY -->  
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="NONE"/>  
	        <xsd:enumeration value="OR"/>  
	        <!--between words -->  
	        <xsd:enumeration value="AND"/>  
	        <!--between words -->  
	        <xsd:enumeration value="STRICTAND"/>  
	        <!--between words - same PCDATA -->  
	        <xsd:enumeration value="EXACTLY"/>  
	        <!-- this sentence -->  
	        <xsd:enumeration value="NOT"/>  
	        <!-- does not contains these cords --> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSWhereAnd"> 
	      <xsd:annotation> 
	        <xsd:documentation>The And operator between WhereConditions</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="whereItems" nillable="false" type="tns:WSWhereItem"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:complexType name="WSWhereOr"> 
	      <xsd:annotation> 
	        <xsd:documentation>The Or operator between WhereConditions</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="whereItems" nillable="false" type="tns:WSWhereItem"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:complexType name="WSWhereItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>An And or Or or WhereCondition</xsd:documentation> 
	      </xsd:annotation>  
	      <!-- It should be only one of them due to lack of support for choice 
	                    <xsd:choice> -->  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="0" name="whereCondition" nillable="false" type="tns:WSWhereCondition"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="whereAnd" nillable="false" type="tns:WSWhereAnd"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="whereOr" nillable="false" type="tns:WSWhereOr"/> 
	      </xsd:sequence>  
	      <!-- </xsd:choice> --> 
	    </xsd:complexType>  
	    <!-- ***************************************************** V I E W ******************************************************* -->  
	    <xsd:complexType name="WSView"> 
	      <xsd:documentation>A filter on items that specify the xPaths to extract, the conditions that the items must meet and the xPaths that can be searched when the user imposes additional search conditions. name: the name of the view description: the description of the view viewableBusinessElements: the visible xPaths (starting with the concept name) of the items found in the view whereConditions: the conditions that all the items must meet searchableBusinessElements: the xPaths (starting with the concept name) of the elements that can be seached to further refine the result</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="viewableBusinessElements" nillable="false" type="xsd:string"/>  
	        <!-- projected business elements -->  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="whereConditions" nillable="true" type="tns:WSWhereCondition"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="searchableBusinessElements" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="transformerPK" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="isTransformerActive" nillable="true" type="tns:WSBoolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSView" type="tns:WSView"/>  
	    <xsd:complexType name="WSViewPK"> 
	      <xsd:documentation>The primary key of a view (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSViewPK" type="tns:WSViewPK"/>  
	    <xsd:complexType name="WSViewPKArray"> 
	      <xsd:documentation>An array of view primary keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSViewPKArray" type="tns:WSViewPKArray"/>  
	    <xsd:complexType name="WSViewArray"> 
	      <xsd:documentation>An array of views</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsViews" nillable="false" type="tns:WSView"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSViewArray" type="tns:WSViewArray"/>  
	    <!-- Operations -->  
	    <xsd:complexType name="WSPutView"> 
	      <xsd:documentation>A message to create/update a view. see WSView</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsView" nillable="false" type="tns:WSView"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutView" type="tns:WSPutView"/>  
	    <xsd:complexType name="WSGetView"> 
	      <xsd:documentation>A message to retrieve a viwe Throws a SOAP exception if the view dooes not exist</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetView" type="tns:WSGetView"/>  
	    <xsd:complexType name="WSExistsView"> 
	      <xsd:documentation>A message to test if a viw exists. Returns the view if it exists, nil otherwise</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsView" type="tns:WSExistsView"/>  
	    <xsd:complexType name="WSDeleteView"> 
	      <xsd:documentation>A message to delete an existing view</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteView" type="tns:WSDeleteView"/>  
	    <xsd:complexType name="WSRegexViews"> 
	      <xsd:documentation>A message to retrieve a list of views using a regular expression on their names</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRegexViews" type="tns:WSRegexViews"/>  
	    <xsd:complexType name="WSGetViewPKs"> 
	      <xsd:documentation>A message to retrieve a list of view primary keys using a regular expression on their names</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetViewPKs" type="tns:WSGetViewPKs"/>  
	    <!-- ***************************************************** S E A R C H 
	                I T E M S ******************************************************* -->  
	    <xsd:complexType name="WSItem"> 
	      <xsd:documentation>An item. wsDataClusterPK: the primary key of the cluster where the item is stored dataModelName: the name of the data model used to validate the item dataModelRevision: the revision of the data model used to validate the item conceptName: the concept of the item ids: a list of values making the primary key of the item insertionTime: the time in millis at whch the item was last stored (e.g. created or overwritten) content: an xml string of the item content</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="dataModelName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="dataModelRevision" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="ids" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="insertionTime" nillable="false" type="xsd:long"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="taskId" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="content" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSItem" type="tns:WSItem"/>  
	    <xsd:complexType name="WSItemPK"> 
	      <xsd:documentation>An item Primary Key wsDataClusterPK: the primary key of the data cluster where the item is stored conceptName: the name of the concept ids: a list of values unique for that concept in that cluster</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="ids" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSItemPK" type="tns:WSItemPK"/>  
	    <xsd:complexType name="WSItemPKArray"> 
	      <xsd:documentation>An array of items primary key</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSItemPKArray" type="tns:WSItemPKArray"/>  
	    <xsd:complexType name="WSBusinessConceptPK"> 
	      <xsd:annotation> 
	        <xsd:documentation>The unique key of a business concept Used with WSGetBusinessConceptValue</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="ids" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBusinessConceptPK" type="tns:WSBusinessConceptPK"/>  
	    <!-- Operations -->  
	    <xsd:complexType name="WSGetItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns an item based on its cluster pk and its key(s)</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItem" type="tns:WSGetItem"/>  
	    <xsd:complexType name="WSExistsItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns whether an item exists</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsItem" type="tns:WSExistsItem"/>  
	    <xsd:complexType name="WSGetItems"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns items based on the cluster pk and a search</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="totalCountOnFirstResult" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItems" type="tns:WSGetItems"/>  
	    <xsd:complexType name="WSGetItemsSort"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns items based on the cluster pk and a search</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="totalCountOnFirstResult" nillable="false" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="sort" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="dir" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItemsSort" type="tns:WSGetItemsSort"/>  
	    <xsd:complexType name="WSGetItemPKsByCriteria"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns items based on criteria</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="contentKeywords" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="keysKeywords" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="fromDate" nillable="true" type="xsd:long"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="toDate" nillable="true" type="xsd:long"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItemPKsByCriteria" type="tns:WSGetItemPKsByCriteria"/>  
	    <xsd:complexType name="WSGetItemPKsByFullCriteria"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns items based on criteria</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsGetItemPKsByCriteria" nillable="false" type="tns:WSGetItemPKsByCriteria"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="useFTSearch" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItemPKsByFullCriteria" type="tns:WSGetItemPKsByFullCriteria"/>  
	    <xsd:complexType name="WSItemPKsByCriteriaResponse"> 
	      <xsd:annotation> 
	        <xsd:documentation>items returned based on criteria</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="results" nillable="false"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="date" nillable="false" type="xsd:long"/>  
	              <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/>  
	              <xsd:element maxOccurs="1" minOccurs="0" name="taskId" nillable="true" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSItemPKsByCriteriaResponse" type="tns:WSItemPKsByCriteriaResponse"/>  
	    <xsd:complexType name="WSCountItemsByCustomFKFilters"> 
	      <xsd:annotation> 
	        <xsd:documentation>Count items based on customized FK filters</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="injectedXpath" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCountItemsByCustomFKFilters" type="tns:WSCountItemsByCustomFKFilters"/>  
	    <xsd:complexType name="WSGetItemsByCustomFKFilters"> 
	      <xsd:annotation> 
	        <xsd:documentation>Return items based on customized FK filters</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="viewablePaths" nillable="false" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="injectedXpath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="orderBy" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="direction" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItemsByCustomFKFilters" type="tns:WSGetItemsByCustomFKFilters"/>  
	    <xsd:complexType name="WSGetBusinessConceptValue"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns the value for a business concept based on its key</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsBusinessConceptPK" nillable="false" type="tns:WSBusinessConceptPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetBusinessConceptValue" type="tns:WSGetBusinessConceptValue"/>  
	    <xsd:complexType name="WSGetFullPathValues"> 
	      <xsd:annotation> 
	        <xsd:documentation>Return all the possible values for a full path starting with the concept name optionally filtered with a condition</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="fullPath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellThreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="orderBy" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="direction" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetFullPathValues" type="tns:WSGetFullPathValues"/>  
	    <xsd:complexType name="WSViewSearch"> 
	      <xsd:annotation> 
	        <xsd:documentation>Performs a search on the searchable elements of a view</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="orderBy" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="direction" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSViewSearch" type="tns:WSViewSearch"/>  
	    <xsd:complexType name="WSXPathsSearch"> 
	      <xsd:annotation> 
	        <xsd:documentation>Performs a search and returns the values for the viewable paths If the pivot is null, the first element of the viewable paths is used</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="pivotPath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="viewablePaths" nillable="false" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="orderBy" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="direction" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="returnCount" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSXPathsSearch" type="tns:WSXPathsSearch"/>  
	    <xsd:complexType name="WSGetItemsPivotIndex"> 
	      <xsd:annotation> 
	        <xsd:documentation>Get items hierarchical tree according to pivots</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="clusterName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="mainPivotName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="pivotWithKeys" nillable="false" type="tns:WSLinkedHashMap"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="indexPaths" nillable="false" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="pivotDirections" nillable="true" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="indexDirections" nillable="true" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="start" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="limit" nillable="false" type="xsd:int"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetItemsPivotIndex" type="tns:WSGetItemsPivotIndex"/>  
	    <xsd:complexType name="WSGetChildrenItems"> 
	      <xsd:annotation> 
	        <xsd:documentation>Get children items</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="clusterName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="PKXpaths" nillable="false" type="tns:WSStringArray"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="FKXpath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="labelXpath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="fatherPK" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="start" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="limit" nillable="false" type="xsd:int"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetChildrenItems" type="tns:WSGetChildrenItems"/>  
	    <xsd:complexType name="WSCount"> 
	      <xsd:annotation> 
	        <xsd:documentation>Counts the number of occurrences of the count path matching the whereItem</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="countPath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="whereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCount" type="tns:WSCount"/>  
	    <xsd:complexType name="WSQuickSearch"> 
	      <xsd:annotation> 
	        <xsd:documentation>Quick searches on the searchable elements of the view</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsViewPK" nillable="false" type="tns:WSViewPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="searchedValue" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="maxItems" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="skip" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="matchAllWords" nillable="false" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="orderBy" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="direction" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSQuickSearch" type="tns:WSQuickSearch"/>  
	    <!-- ***************************************************** P U T I T E 
	                M ******************************************************* -->  
	    <xsd:complexType name="WSPutItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Puts an item in the xml storage.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xmlString" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataModelPK" nillable="false" type="tns:WSDataModelPK"/>  
	        <xsd:element default="false" maxOccurs="1" minOccurs="0" name="isUpdate" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutItem" type="tns:WSPutItem"/>  
	    <xsd:complexType name="WSPutItemArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsPutItem" nillable="true" type="tns:WSPutItem"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutItemArray" type="tns:WSPutItemArray"/>  
	    <xsd:complexType name="WSUpdateReportItemPOJO"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="path" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="newValue" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="oldValue" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSUpdateReportItemPOJO" type="tns:WSUpdateReportItemPOJO"/>  
	    <xsd:complexType name="WSUpdateReportItemArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsUpdateReportItemPOJO" nillable="true" type="tns:WSUpdateReportItemPOJO"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSUpdateReportItemArray" type="tns:WSUpdateReportItemArray"/>  
	    <xsd:complexType name="WSPutItemWithReport"> 
	      <xsd:annotation> 
	        <xsd:documentation>Puts an item in the xml storage with update report</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsPutItem" nillable="false" type="tns:WSPutItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="source" nillable="false" type="xsd:string"/>  
	        <xsd:element default="true" maxOccurs="1" minOccurs="0" name="invokeBeforeSaving" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutItemWithReport" type="tns:WSPutItemWithReport"/>  
	    <xsd:complexType name="WSPutItemWithCustomReport"> 
	      <xsd:annotation> 
	        <xsd:documentation>Puts an item in the xml storage with custom update report</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsPutItemWithReport" nillable="false" type="tns:WSPutItemWithReport"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="user" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutItemWithCustomReport" type="tns:WSPutItemWithCustomReport"/>  
	    <xsd:complexType name="WSPutItemWithReportArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsPutItem" nillable="true" type="tns:WSPutItemWithReport"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutItemWithReportArray" type="tns:WSPutItemWithReportArray"/>  
	    <xsd:complexType name="WSIsItemModifiedByOther"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItem" nillable="true" type="tns:WSItem"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSIsItemModifiedByOther" type="tns:WSIsItemModifiedByOther"/>  
	    <xsd:complexType name="WSPartialPutItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Partial Puts an item in the xml storage.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="xml" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="datacluster" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="pivot" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="datamodel" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="keyXPath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" default="-1" name="startingPosition" nillable="false" type="xsd:int"/>  
	        <xsd:element default="false" maxOccurs="1" minOccurs="0" name="overwrite" nillable="false" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPartialPutItem" type="tns:WSPartialPutItem"/>  
	    <!-- ***************************************************** D E L E T E 
	                I T E M S ******************************************************* -->  
	    <xsd:complexType name="WSDeleteItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Delete an item based on its cluster pk and its key(s)</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="override" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteItem" type="tns:WSDeleteItem"/>  
	    <xsd:complexType name="WSDeleteItemWithReport"> 
	      <xsd:annotation> 
	        <xsd:documentation>Delete an item based on its cluster pk and its key(s) with report</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="source" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="operateType" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="updatePath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="user" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="invokeBeforeSaving" nillable="true" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="pushToUpdateReport" nillable="true" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="override" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteItemWithReport" type="tns:WSDeleteItemWithReport"/>  
	    <xsd:complexType name="WSDeleteItems"> 
	      <xsd:annotation> 
	        <xsd:documentation>Delete items of a concept based on a query</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsWhereItem" nillable="true" type="tns:WSWhereItem"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="spellTreshold" nillable="false" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="override" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteItems" type="tns:WSDeleteItems"/>  
	    <xsd:complexType name="WSDropItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Drop an item to items trash</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="partPath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="override" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDropItem" type="tns:WSDropItem"/>  
	    <!-- ***************************************************** D I R E C T 
	                Q U E R Y ** !!! Use of this is fast but dangerous and makes !!! ** !!! code 
	                non portable accross xml servers !!! ******************************************************* -->  
	    <xsd:complexType name="WSRunQuery"> 
	      <xsd:annotation> 
	        <xsd:documentation>Runs an xQuery on the XML DB in the revision ID, the Query is run from the DataCluster at the head The Data Cluster can be null to run cross-cluster queries ** !!! Use of this is fast but dangerous and makes !!! ** !!! code non portable accross xml servers !!!</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="true" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="query" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRunQuery" type="tns:WSRunQuery"/>  
	    <!-- ***************************************************** C O N N E C 
	                T O R ******************************************************* -->  
	    <xsd:complexType name="WSBase64KeyValue"> 
	      <xsd:documentation>An object used to pass data to a connector in a connector interaction - see WSConnectorInteraction</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="key" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="base64StringValue" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:simpleType name="WSConnectorFunction"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="GET_STATUS"/>  
	        <xsd:enumeration value="START"/>  
	        <xsd:enumeration value="STOP"/>  
	        <xsd:enumeration value="PULL"/>  
	        <xsd:enumeration value="PUSH"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSConnectorInteraction"> 
	      <xsd:documentation>A message to interact with a connector JNDIName: the JNDI name of the connector function: one of the enumerated interactions - see WSConnectorFunction parameters: parameters to pass to the connector - see WSBase64KeyValue</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="JNDIName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="function" nillable="true" type="tns:WSConnectorFunction"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="tns:WSBase64KeyValue"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSConnectorInteraction" type="tns:WSConnectorInteraction"/>  
	    <xsd:simpleType name="WSConnectorResponseCode"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="OK"/>  
	        <xsd:enumeration value="STOPPED"/>  
	        <xsd:enumeration value="ERROR"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSConnectorInteractionResponse"> 
	      <xsd:documentation>The response to an interaction with a connector - see WSConnectorInteraction</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="code" nillable="true" type="tns:WSConnectorResponseCode"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="true" type="tns:WSBase64KeyValue"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSConnectorInteractionResponse" type="tns:WSConnectorInteractionResponse"/>  
	    <!-- ***************************************************** SERVICES ******************************************************* -->  
	    <xsd:simpleType name="WSServiceActionCode"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="START"/>  
	        <xsd:enumeration value="STOP"/>  
	        <xsd:enumeration value="STATUS"/>  
	        <xsd:enumeration value="EXECUTE"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:element name="WSServiceActionCode" type="tns:WSServiceActionCode"/>  
	    <xsd:complexType name="WSServicesList"> 
	      <xsd:documentation>A list of JNDI names belonging to services</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="Item"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="jndiName" nillable="false" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSServicesList" type="tns:WSServicesList"/>  
	    <!-- ******************** A C T I O N S************************* -->  
	    <xsd:complexType name="WSGetServicesList"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns the list of available Services in a WSServicesList that provides their JNDI Name</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="language" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetServicesList" type="tns:WSGetServicesList"/>  
	    <xsd:complexType name="WSServiceAction"> 
	      <xsd:documentation>A message to perform an action on a service jndiName: the JNDI name of the service wsAction: the action to take on the service - see WSServiceActionCode methodName: the service method name to call (a public EJB method) methodParameters: a list of parameters to pass to the method</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jndiName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsAction" nillable="false" type="tns:WSServiceActionCode"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="methodName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="methodParameters" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSServiceAction" type="tns:WSServiceAction"/>  
	    <xsd:complexType name="WSServicePutConfiguration"> 
	      <xsd:documentation>A message to store a configuration of a service on the server jndiName: the JNDI name of the service configuration: the configuration of the service to store on the server</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jndiName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="configuration" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSServicePutConfiguration" type="tns:WSServicePutConfiguration"/>  
	    <xsd:complexType name="WSServiceGetConfiguration"> 
	      <xsd:documentation>A message to retrieve the configuration of a service jndiName: the JNDI name of the service otionalParameter: an optional parameter to pass on the call</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jndiName" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="optionalParameter" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSServiceGetConfiguration" type="tns:WSServiceGetConfiguration"/>  
	    <xsd:complexType name="WSServiceGetDocument"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="configure" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="document" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="configureSchema" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="defaultConfig" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSServiceGetDocument" type="tns:WSServiceGetDocument"/>  
	    <!-- ***************************************************** Stored Procedures 
	                ******************************************************* -->  
	    <xsd:complexType name="WSStoredProcedure"> 
	      <xsd:documentation>A stored procedure name: the unique name of the procedure description: the optional description of the procedure procedure: the xQuery</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="procedure" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="refreshCache" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSStoredProcedure" type="tns:WSStoredProcedure"/>  
	    <xsd:complexType name="WSStoredProcedurePK"> 
	      <xsd:documentation>The primary key of a stored procedure (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSStoredProcedurePK" type="tns:WSStoredProcedurePK"/>  
	    <xsd:complexType name="WSRegexStoredProcedure"> 
	      <xsd:documentation>A message to retrieve stored procedures which names match a regular expression</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRegexStoredProcedure" type="tns:WSRegexStoredProcedure"/>  
	    <xsd:complexType name="WSStoredProcedurePKArray"> 
	      <xsd:documentation>A list of stored procedures primary keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsStoredProcedurePK" nillable="false" type="tns:WSStoredProcedurePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSStoredProcedurePKArray" type="tns:WSStoredProcedurePKArray"/>  
	    <xsd:complexType name="WSGetStoredProcedure"> 
	      <xsd:documentation>A message to retrieve a stored procedure. An exception will be thrown if the stored procedure does not exist.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsStoredProcedurePK" nillable="false" type="tns:WSStoredProcedurePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetStoredProcedure" type="tns:WSGetStoredProcedure"/>  
	    <xsd:complexType name="WSExistsStoredProcedure"> 
	      <xsd:documentation>A message to check that a stored procedure exists. Will return the stored procedure if found, nil otherwise.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsStoredProcedurePK" nillable="false" type="tns:WSStoredProcedurePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsStoredProcedure" type="tns:WSExistsStoredProcedure"/>  
	    <xsd:complexType name="WSPutStoredProcedure"> 
	      <xsd:documentation>A message to create/overwrite a stored procedure</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsStoredProcedure" nillable="false" type="tns:WSStoredProcedure"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutStoredProcedure" type="tns:WSPutStoredProcedure"/>  
	    <xsd:complexType name="WSDeleteStoredProcedure"> 
	      <xsd:documentation>A message to delete a stored procedure.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsStoredProcedurePK" nillable="false" type="tns:WSStoredProcedurePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteStoredProcedure" type="tns:WSDeleteStoredProcedure"/>  
	    <xsd:complexType name="WSExecuteStoredProcedure"> 
	      <xsd:documentation>A message to execute a stored procedure. wsStoredProcedurePK: the primary key of the procedure to execute revisionID: the revisionID of the procedure wsDataClusterPK: the cluster where the procedure will be executed. If nil, the procedure will use the root of the DB as context. parameters: parameters passed to the stored procedure that will replace the {n} where n is the nth parameter</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsStoredProcedurePK" nillable="false" type="tns:WSStoredProcedurePK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="true" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="parameters" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExecuteStoredProcedure" type="tns:WSExecuteStoredProcedure"/>  
	    <xsd:complexType name="WSGetStoredProcedurePKs"> 
	      <xsd:documentation>A message to retrieved stored procedure primary keys which names match a particular regex</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetStoredProcedurePKs" type="tns:WSGetStoredProcedurePKs"/>  
	    <!-- ***************************************************** Menus ******************************************************* -->  
	    <xsd:complexType name="WSMenu"> 
	      <xsd:documentation>A menu. name: the unique name of the menu description: the description of the menu menuEntries: a list of entries tha make up the menu - see WSMenuEntry</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="menuEntries" nillable="false" type="tns:WSMenuEntry"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMenu" type="tns:WSMenu"/>  
	    <xsd:complexType name="WSMenuEntry"> 
	      <xsd:documentation>An entry in a menu (a menu item). id: the unique id of the entry descriptions: a list of localized string made of their label and respective two letter code language context: the context of the webapp that should be launched when clicking on the entry application: the name of the application within the context that should be launched when clicking on the entry subMenu: a list of nested menu entries that make up the sub menus</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="id" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="descriptions" nillable="false"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element maxOccurs="1" minOccurs="1" name="language" nillable="false" type="xsd:string"/>  
	              <xsd:element maxOccurs="1" minOccurs="1" name="label" nillable="false" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="context" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="application" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="icon" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="subMenus" nillable="false" type="tns:WSMenuEntry"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMenuEntry" type="tns:WSMenuEntry"/>  
	    <xsd:complexType name="WSMenuPK"> 
	      <xsd:documentation>The primary key of a menu (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMenuPK" type="tns:WSMenuPK"/>  
	    <xsd:complexType name="WSMenuPKArray"> 
	      <xsd:documentation>A list of menu primary keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsMenuPK" nillable="false" type="tns:WSMenuPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMenuPKArray" type="tns:WSMenuPKArray"/>  
	    <xsd:complexType name="WSGetMenu"> 
	      <xsd:documentation>A message to retrieve an existing menu. Throws a SOAP Exception if the menu is not found</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsMenuPK" nillable="false" type="tns:WSMenuPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetMenu" type="tns:WSGetMenu"/>  
	    <xsd:complexType name="WSExistsMenu"> 
	      <xsd:documentation>A message to check that a menu exists Returns the menu if it exists, nil otherwise</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsMenuPK" nillable="false" type="tns:WSMenuPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsMenu" type="tns:WSExistsMenu"/>  
	    <xsd:complexType name="WSPutMenu"> 
	      <xsd:documentation>A message to create/overwrite a menu</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsMenu" nillable="false" type="tns:WSMenu"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutMenu" type="tns:WSPutMenu"/>  
	    <xsd:complexType name="WSDeleteMenu"> 
	      <xsd:documentation>A message to delete an existing menu</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsMenuPK" nillable="false" type="tns:WSMenuPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteMenu" type="tns:WSDeleteMenu"/>  
	    <xsd:complexType name="WSGetMenuPKs"> 
	      <xsd:documentation>A message to retrieve a list of menu primary keys which names match a regular expression</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetMenuPKs" type="tns:WSGetMenuPKs"/>  
	    <!-- ***************************************************** Dropped Item 
	                ******************************************************* -->  
	    <xsd:complexType name="WSDroppedItem"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDataClusterPK" nillable="false" type="tns:WSDataClusterPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="uniqueId" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conceptName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="ids" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="partPath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="insertionUserName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="insertionTime" nillable="true" type="xsd:long"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="projection" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDroppedItem" type="tns:WSDroppedItem"/>  
	    <xsd:complexType name="WSDroppedItemPK"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsItemPK" nillable="false" type="tns:WSItemPK"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="partPath" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="revisionId" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDroppedItemPK" type="tns:WSDroppedItemPK"/>  
	    <xsd:complexType name="WSDroppedItemPKArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsDroppedItemPK" nillable="false" type="tns:WSDroppedItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDroppedItemPKArray" type="tns:WSDroppedItemPKArray"/>  
	    <xsd:complexType name="WSFindAllDroppedItemsPKs"> 
	      <xsd:annotation> 
	        <xsd:documentation>Find all dropped items in items trash</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSFindAllDroppedItemsPKs" type="tns:WSFindAllDroppedItemsPKs"/>  
	    <xsd:complexType name="WSLoadDroppedItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Load a dropped item from items trash</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDroppedItemPK" nillable="false" type="tns:WSDroppedItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSLoadDroppedItem" type="tns:WSLoadDroppedItem"/>  
	    <xsd:complexType name="WSRecoverDroppedItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Recover a dropped item from items trash</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDroppedItemPK" nillable="false" type="tns:WSDroppedItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRecoverDroppedItem" type="tns:WSRecoverDroppedItem"/>  
	    <xsd:complexType name="WSRemoveDroppedItem"> 
	      <xsd:annotation> 
	        <xsd:documentation>Remove a dropped item from items trash</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsDroppedItemPK" nillable="false" type="tns:WSDroppedItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRemoveDroppedItem" type="tns:WSRemoveDroppedItem"/>  
	    <xsd:simpleType name="WSGetUniverseByRevisionType"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="ITEM"/>  
	        <xsd:enumeration value="OBJECT"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSGetUniverseByRevision"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="namepattern" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="revision" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="type" nillable="false" type="tns:WSGetUniverseByRevisionType"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetUniverseByRevision" type="tns:WSGetUniverseByRevision"/>  
	    <xsd:complexType name="WSMDMConfig"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="serverName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="serverPort" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="userName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="password" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xdbDriver" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xdbID" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="xdbUrl" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="isupurl" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMDMConfig" type="tns:WSMDMConfig"/>  
	    <xsd:complexType name="WSCheckServiceConfigRequest"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jndiName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="conf" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCheckServiceConfigRequest" type="tns:WSCheckServiceConfigRequest"/>  
	    <xsd:complexType name="WSCheckServiceConfigResponse"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="checkResult" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCheckServiceConfigResponse" type="tns:WSCheckServiceConfigResponse"/>  
	    <!-- ***************************************************** ROUTING RULE 
	                ******************************************************* -->  
	    <xsd:simpleType name="WSRoutingRuleOperator"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="CONTAINS"/>  
	        <xsd:enumeration value="MATCHES"/>  
	        <xsd:enumeration value="STARTSWITH"/>  
	        <xsd:enumeration value="EQUALS"/>  
	        <xsd:enumeration value="NOT_EQUALS"/>  
	        <xsd:enumeration value="GREATER_THAN"/>  
	        <xsd:enumeration value="GREATER_THAN_OR_EQUAL"/>  
	        <xsd:enumeration value="LOWER_THAN"/>  
	        <xsd:enumeration value="LOWER_THAN_OR_EQUAL"/>  
	        <xsd:enumeration value="IS_NULL"/>  
	        <xsd:enumeration value="IS_NOT_NULL"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSRoutingRuleExpression"> 
	      <xsd:documentation>A conditional expression in a routing rule name: the name of the condition xPath: the xPath applied to the item for the left hand value operator: one of the possible operators - see WSRoutingRuleOperator value: the right hand value</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="0" name="name" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="xpath" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="wsOperator" nillable="true" type="tns:WSRoutingRuleOperator"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="value" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:complexType name="WSRoutingRule"> 
	      <xsd:documentation>A routing rule name: the unique name of the rule description: an optional description synchronous: whether the rule is executed synchronously or asynchronously by the routing engine concept: the item concept to match. A '*' matches any concept serviceJNDI: the JNDI entry of the service to call when the routing rule matches parameters: the parmaters to be passed to the service wsRoutingRuleExpressions: conditional consitions that item must meet for the rule to match deactive: true to deactivate the rule</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="name" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="synchronous" nillable="false" type="xsd:boolean"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="concept" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="serviceJNDI" nillable="false" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="parameters" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsRoutingRuleExpressions" nillable="true" type="tns:WSRoutingRuleExpression"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="condition" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" name="deactive" nillable="true" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingRule" type="tns:WSRoutingRule"/>  
	    <xsd:complexType name="WSRoutingRulePK"> 
	      <xsd:documentation>The primary key of a routing rule (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingRulePK" type="tns:WSRoutingRulePK"/>  
	    <xsd:complexType name="WSRoutingRuleArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsRoutingRules" nillable="true" type="tns:WSRoutingRule"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingRuleArray" type="tns:WSRoutingRuleArray"/>  
	    <xsd:complexType name="WSRoutingRulePKArray"> 
	      <xsd:documentation>A list of routing rules</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="1" name="wsRoutingRulePKs" nillable="true" type="tns:WSRoutingRulePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingRulePKArray" type="tns:WSRoutingRulePKArray"/>  
	    <!-- Operations -->  
	    <xsd:complexType name="WSPutRoutingRule"> 
	      <xsd:documentation>A message to create/overwrite a routing rule</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsRoutingRule" nillable="false" type="tns:WSRoutingRule"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutRoutingRule" type="tns:WSPutRoutingRule"/>  
	    <xsd:complexType name="WSGetRoutingRule"> 
	      <xsd:documentation>A message to retrieve a routing rule. Throws an Exception if the rule is not found.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsRoutingRulePK" nillable="false" type="tns:WSRoutingRulePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingRule" type="tns:WSGetRoutingRule"/>  
	    <xsd:complexType name="WSExistsRoutingRule"> 
	      <xsd:documentation>A message to check the existence of a routing rule. Returns the rule if found, nil otherwise.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsRoutingRulePK" nillable="false" type="tns:WSRoutingRulePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsRoutingRule" type="tns:WSExistsRoutingRule"/>  
	    <xsd:complexType name="WSDeleteRoutingRule"> 
	      <xsd:documentation>A messaage to delete an existing routing rule</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="wsRoutingRulePK" nillable="false" type="tns:WSRoutingRulePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteRoutingRule" type="tns:WSDeleteRoutingRule"/>  
	    <xsd:complexType name="WSGetRoutingRulePKs"> 
	      <xsd:documentation>A message to list the primary keys of routing rules which names match a regular expression</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="regex" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingRulePKs" type="tns:WSGetRoutingRulePKs"/>  
	    <xsd:complexType name="WSMDMNULL"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="0" minOccurs="0" name="mdmjob" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMDMNULL" type="tns:WSMDMNULL"/>  
	    <xsd:complexType name="WSPUTMDMJob"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobVersion" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPUTMDMJob" type="tns:WSPUTMDMJob"/>  
	    <xsd:complexType name="WSDELMDMJob"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobVersion" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDELMDMJob" type="tns:WSDELMDMJob"/>  
	    <xsd:complexType name="WSMDMJob"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobName" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="jobVersion" nillable="true" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" name="suffix" nillable="true" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMDMJob" type="tns:WSMDMJob"/>  
	    <xsd:complexType name="WSMDMJobArray"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="unbounded" minOccurs="0" name="wsMDMJob" nillable="false" type="tns:WSMDMJob"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSMDMJobArray" type="tns:WSMDMJobArray"/>  
	    <xsd:complexType name="WSCategoryData"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="categorySchema" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSCategoryData" type="tns:WSCategoryData"/>  
	    <xsd:complexType name="WSAutoIncrement"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" name="autoincrement" nillable="false" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSAutoIncrement" type="tns:WSAutoIncrement"/>  
	    <!-- ***************************************************** E X T R A C 
	                T I T E M S ******************************************************* -->  
	    <xsd:complexType name="WSExtractedContent"> 
	      <xsd:annotation> 
	        <xsd:documentation>Content extracted using one of the ExtractUsingTransformer web service</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsByteArray" type="tns:WSByteArray"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="contentType" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExtractedContent" type="tns:WSExtractedContent"/>  
	    <xsd:complexType name="WSPipeline"> 
	      <xsd:annotation> 
	        <xsd:documentation>The pipeline after running a transformer</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="true" name="typedContentEntry"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="output" type="xsd:string"/>  
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsExtractedContent" type="tns:WSExtractedContent"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPipeline" type="tns:WSPipeline"/>  
	    <xsd:complexType name="WSExtractUsingTransformer"> 
	      <xsd:annotation> 
	        <xsd:documentation>Extracts data using a Transformer</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsItemPK" type="tns:WSItemPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExtractUsingTransformer" type="tns:WSExtractUsingTransformer"/>  
	    <xsd:complexType name="WSExtractUsingTransformerThruView"> 
	      <xsd:annotation> 
	        <xsd:documentation>Extract data using a Transformer and thru a View Data is returned in the pipeline in com.amalto.core.extract.xxx where xxx is sequential number starting from 1</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsDataClusterPK" type="tns:WSDataClusterPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsViewPK" type="tns:WSViewPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="whereItem" type="tns:WSWhereItem"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="spellTreshold" type="xsd:int"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="skip" type="xsd:int"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="maxItems" type="xsd:int"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="true" name="orderBy" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="true" name="direction" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExtractUsingTransformerThruView" type="tns:WSExtractUsingTransformerThruView"/>  
	    <!-- ***************************************************** Transformers 
	                - DEPRECATED - Use Transformers V2 ******************************************************* -->  
	    <xsd:complexType name="WSTransformerPluginSpec"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="PluginJNDI" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="input" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="output" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="parameters" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginSpec" type="tns:WSTransformerPluginSpec"/>  
	    <xsd:complexType name="WSTransformer"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="name" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="pluginSpecs" type="tns:WSTransformerPluginSpec"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformer" type="tns:WSTransformer"/>  
	    <xsd:complexType name="WSTransformerPK"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPK" type="tns:WSTransformerPK"/>  
	    <xsd:complexType name="WSTransformerPKArray"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPKArray" type="tns:WSTransformerPKArray"/>  
	    <xsd:complexType name="WSGetTransformer"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformer" type="tns:WSGetTransformer"/>  
	    <xsd:complexType name="WSExistsTransformer"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsTransformer" type="tns:WSExistsTransformer"/>  
	    <xsd:complexType name="WSPutTransformer"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformer" type="tns:WSTransformer"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutTransformer" type="tns:WSPutTransformer"/>  
	    <xsd:complexType name="WSDeleteTransformer"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteTransformer" type="tns:WSDeleteTransformer"/>  
	    <xsd:complexType name="WSGetTransformerPKs"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="regex" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformerPKs" type="tns:WSGetTransformerPKs"/>  
	    <xsd:complexType name="WSProcessBytesUsingTransformer"> 
	      <xsd:annotation> 
	        <xsd:documentation>Process Bytes after transformation in a Transformer and using a DecisionTable for the ouput variables</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsBytes" type="tns:WSByteArray"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="contentType" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSProcessBytesUsingTransformer" type="tns:WSProcessBytesUsingTransformer"/>  
	    <xsd:complexType name="WSProcessFileUsingTransformer"> 
	      <xsd:annotation> 
	        <xsd:documentation>Processes the content of a local (to the data manager) file after transformation in a Transformer and using a DecisionTable for the ouput variables</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="fileName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="contentType" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSProcessFileUsingTransformer" type="tns:WSProcessFileUsingTransformer"/>  
	    <xsd:complexType name="WSProcessBytesUsingTransformerAsBackgroundJob"> 
	      <xsd:annotation> 
	        <xsd:documentation>Process Bytes after transformation in a Transformer and using a DecisionTable for the ouput variables Uses a Background Job. Call getBackGroundJob to follow the Job Process</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsBytes" type="tns:WSByteArray"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="contentType" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSProcessBytesUsingTransformerAsBackgroundJob" type="tns:WSProcessBytesUsingTransformerAsBackgroundJob"/>  
	    <xsd:complexType name="WSProcessFileUsingTransformerAsBackgroundJob"> 
	      <xsd:annotation> 
	        <xsd:documentation>Processes the content of a local (to the data manager) file after transformation in a Transformer and using a DecisionTable for the ouput variables Uses a Background Job. Call getBackGroundJob to follow the Job Process</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="fileName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="contentType" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsOutputDecisionTable" type="tns:WSOutputDecisionTable"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSProcessFileUsingTransformerAsBackgroundJob" type="tns:WSProcessFileUsingTransformerAsBackgroundJob"/>  
	    <xsd:complexType name="WSOutputDecisionTable"> 
	      <xsd:annotation> 
	        <xsd:documentation>Used by the WSProcess...UsingTransformer The decision Tables specifies what happens to the ouptut variables NONE: the variables is present in the pipeline with its content DISCARD: the variable and its content is removed from the pipeline before the web service returns PROJECT(DataCluster,DataModel[,overwrite]): the content is projected to DataCluster after having been validated by DataModel. "overwrite" specifies whether to overwrite an existing item and is true by default. Possible values are true or false</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="decisions"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="outputVariableName" type="xsd:string"/>  
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="decision" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSOutputDecisionTable" type="tns:WSOutputDecisionTable"/>  
	    <!-- ***************************************************** Objects ******************************************************* -->  
	    <xsd:simpleType name="BackgroundJobStatusType"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="SCHEDULED"/>  
	        <xsd:enumeration value="RUNNING"/>  
	        <xsd:enumeration value="COMPLETED"/>  
	        <xsd:enumeration value="SUSPENDED"/>  
	        <xsd:enumeration value="CANCEL_REQUESTED"/>  
	        <xsd:enumeration value="STOPPED"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSBackgroundJob"> 
	      <xsd:annotation> 
	        <xsd:documentation>Background Jobs are created and updated by asynchronous methods ending up with ...AsJob Use getBackgroundJob to read the progress of the job and read the status.</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" name="id" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" name="description" nillable="true" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" name="status" nillable="false" type="tns:BackgroundJobStatusType"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" name="message" nillable="true" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" name="percentage" nillable="true" type="xsd:int"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" name="timestamp" nillable="true" type="xsd:string"/>  
	        <!-- choice -->  
	        <!--Deprecated - include for compatibility with core 2.17 -->  
	        <xsd:element minOccurs="0" maxOccurs="1" name="pipeline" nillable="true" type="tns:WSPipeline"/>  
	        <!--For core 2.18+ -->  
	        <xsd:element minOccurs="0" maxOccurs="1" name="serializedObject" nillable="true" type="xsd:base64Binary"/>  
	        <!-- choice --> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBackgroundJob" type="tns:WSBackgroundJob"/>  
	    <xsd:complexType name="WSBackgroundJobPKArray"> 
	      <xsd:documentation>A list od Background Jobs Primary Keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsBackgroundJobPK" type="tns:WSBackgroundJobPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBackgroundJobPKArray" type="tns:WSBackgroundJobPKArray"/>  
	    <xsd:complexType name="WSBackgroundJobPK"> 
	      <xsd:documentation>A Background Job Primary Key</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSBackgroundJobPK" type="tns:WSBackgroundJobPK"/>  
	    <!-- ***************************************************** Operations 
	                ******************************************************* -->  
	    <xsd:complexType name="WSPutBackgroundJob"> 
	      <xsd:documentation>A message to create/overwrite a Background Job</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" name="wsBackgroundJob" type="tns:WSBackgroundJob"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutBackgroundJob" type="tns:WSPutBackgroundJob"/>  
	    <xsd:complexType name="WSGetBackgroundJob"> 
	      <xsd:documentation>A message to retrieve a Background Job</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetBackgroundJob" type="tns:WSGetBackgroundJob"/>  
	    <xsd:complexType name="WSFindBackgroundJobPKs"> 
	      <xsd:documentation>A message to retrieve Background Jobs based on their status</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" name="status" type="tns:BackgroundJobStatusType"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSFindBackgroundJobPKs" type="tns:WSFindBackgroundJobPKs"/>  
	    <!-- ***************************************************** Universe Objects 
	                ******************************************************* -->  
	    <xsd:complexType name="WSUniverse"> 
	      <xsd:documentation>An Universe name: the unique name of the Universe description: the optional description of the Universe xtentisObjectsRevisionIDs: the revision IDs applying to the various MDM Objects in this Universe &gt;xtentisObjectName: the name of the MDM Object &gt;revisionID: the revision ID of the Object defaultItemsRevisionID: the Revision ID to apply by default to Items for which a Revision ID has no been specified itemsRevisionIDs: the Revision IDs to apply to the Items &gt;conceptPattern: a pattern that matches the Concept of the Items &gt;revisionID: the Revision ID to apply to this Items</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="name" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="xtentisObjectsRevisionIDs"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="xtentisObjectName" type="xsd:string"/>  
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="revisionID" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="defaultItemsRevisionID" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="itemsRevisionIDs"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="conceptPattern" type="xsd:string"/>  
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="revisionID" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSUniverse" type="tns:WSUniverse"/>  
	    <xsd:complexType name="WSUniversePK"> 
	      <xsd:documentation>An Universe Primary Key (its name)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSUniversePK" type="tns:WSUniversePK"/>  
	    <xsd:complexType name="WSUniversePKArray"> 
	      <xsd:documentation>An Array of Universe Primary Keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsUniversePK" type="tns:WSUniversePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSUniversePKArray" type="tns:WSUniversePKArray"/>  
	    <!-- ***************************************************** Universe Operations 
	                ******************************************************* -->  
	    <xsd:complexType name="WSGetUniverse"> 
	      <xsd:documentation>A mesage to retrieve an Universe</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsUniversePK" type="tns:WSUniversePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetUniverse" type="tns:WSGetUniverse"/>  
	    <xsd:complexType name="WSExistsUniverse"> 
	      <xsd:documentation>A message to determine if an Universe exists</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsUniversePK" type="tns:WSUniversePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsUniverse" type="tns:WSExistsUniverse"/>  
	    <xsd:complexType name="WSPutUniverse"> 
	      <xsd:documentation>A message to create/overwrite an Universe</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsUniverse" type="tns:WSUniverse"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutUniverse" type="tns:WSPutUniverse"/>  
	    <xsd:complexType name="WSDeleteUniverse"> 
	      <xsd:documentation>A message to delete an Universe</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsUniversePK" type="tns:WSUniversePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteUniverse" type="tns:WSDeleteUniverse"/>  
	    <xsd:complexType name="WSGetUniversePKs"> 
	      <xsd:documentation>A message to retrieve all the Universe Primary Keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="regex" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetUniversePKs" type="tns:WSGetUniversePKs"/>  
	    <xsd:complexType name="WSGetObjectsForUniverses"> 
	      <xsd:annotation> 
	        <xsd:documentation>Return the xtentis object names for which a revision ID can be set</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="regex" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetObjectsForUniverses" type="tns:WSGetObjectsForUniverses"/>  
	    <xsd:complexType name="WSGetCurrentUniverse"> 
	      <xsd:annotation> 
	        <xsd:documentation>Return the Universe the calling user is using</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="true" name="dummy" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetCurrentUniverse" type="tns:WSGetCurrentUniverse"/>  
	    <xsd:complexType name="WSGetConceptsInDataClusterWithRevisions"> 
	      <xsd:documentation>A message to retrieve the Revision IDs of the Concepts in a given Data Cluster</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="dataClusterPOJOPK" type="tns:WSDataClusterPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="universePK" type="tns:WSUniversePK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetConceptsInDataClusterWithRevisions" type="tns:WSGetConceptsInDataClusterWithRevisions"/>  
	    <!-- ***************************************************** Transformer 
	                V2 Objects ******************************************************* -->  
	    <xsd:complexType name="WSTransformerContext"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerPK" type="tns:WSTransformerV2PK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="pipeline"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element name="pipelineItem" minOccurs="0" maxOccurs="unbounded"> 
	                <xsd:complexType> 
	                  <xsd:sequence> 
	                    <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="variable" type="xsd:string"/>  
	                    <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsTypedContent" type="tns:WSTypedContent"/> 
	                  </xsd:sequence> 
	                </xsd:complexType> 
	              </xsd:element> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="false" name="projectedItemPKs"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element name="wsItemPOJOPK" minOccurs="1" maxOccurs="unbounded" nillable="false" type="tns:WSItemPK"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerContext" type="tns:WSTransformerContext"/>  
	    <xsd:complexType name="WSTransformerVariablesMapping"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="pipelineVariable" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="pluginVariable" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="true" name="hardCoding" type="tns:WSTypedContent"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerVariablesMapping" type="tns:WSTransformerVariablesMapping"/>  
	    <xsd:complexType name="WSTransformerProcessStep"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="PluginJNDI" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="parameters" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="true" name="inputMappings" type="tns:WSTransformerVariablesMapping"/>  
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="true" name="outputMappings" type="tns:WSTransformerVariablesMapping"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="false" name="disabled" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerProcessStep" type="tns:WSTransformerProcessStep"/>  
	    <xsd:complexType name="WSTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="name" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="processSteps" type="tns:WSTransformerProcessStep"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerV2" type="tns:WSTransformerV2"/>  
	    <xsd:complexType name="WSTransformerV2PK"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="pk" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerV2PK" type="tns:WSTransformerV2PK"/>  
	    <xsd:complexType name="WSTransformerV2PKArray"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerV2PKArray" type="tns:WSTransformerV2PKArray"/>  
	    <!-- ***************************************************** TransformerV2 
	                Operations ******************************************************* -->  
	    <xsd:complexType name="WSGetTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformerV2" type="tns:WSGetTransformerV2"/>  
	    <xsd:complexType name="WSExistsTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsTransformerV2" type="tns:WSExistsTransformerV2"/>  
	    <xsd:complexType name="WSPutTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerV2" type="tns:WSTransformerV2"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSPutTransformerV2" type="tns:WSPutTransformerV2"/>  
	    <xsd:complexType name="WSDeleteTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteTransformerV2" type="tns:WSDeleteTransformerV2"/>  
	    <xsd:complexType name="WSGetTransformerV2PKs"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="regex" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformerV2PKs" type="tns:WSGetTransformerV2PKs"/>  
	    <xsd:complexType name="WSExecuteTransformerV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="wsTransformerContext" type="tns:WSTransformerContext"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="true" name="wsTypedContent" type="tns:WSTypedContent"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExecuteTransformerV2" type="tns:WSExecuteTransformerV2"/>  
	    <xsd:complexType name="WSExecuteTransformerV2AsJob"> 
	      <xsd:annotation> 
	        <xsd:documentation>Starts the execution of a transformer as a background job and return the PK of a Background Job The result must be obtained by reading the content of the BackgroundJob</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerContext" type="tns:WSTransformerContext"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExecuteTransformerV2AsJob" type="tns:WSExecuteTransformerV2AsJob"/>  
	    <xsd:complexType name="WSExtractThroughTransformerV2"> 
	      <xsd:annotation> 
	        <xsd:documentation>Extracts data through a Transformer The item content is mapped to the _DEFAULT_ transformer variable</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsItemPK" type="tns:WSItemPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsTransformerV2PK" type="tns:WSTransformerV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExtractThroughTransformerV2" type="tns:WSExtractThroughTransformerV2"/>  
	    <!-- ***************************************************** Transformer 
	                Plugins V2 - Objects ******************************************************* -->  
	    <xsd:complexType name="WSExistsTransformerPluginV2"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="jndiName" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsTransformerPluginV2" type="tns:WSExistsTransformerPluginV2"/>  
	    <xsd:complexType name="WSTransformerPluginV2PutConfiguration"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="jndiName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="configuration" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginV2PutConfiguration" type="tns:WSTransformerPluginV2PutConfiguration"/>  
	    <xsd:complexType name="WSTransformerPluginV2GetConfiguration"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="jndiName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="optionalParameter" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginV2GetConfiguration" type="tns:WSTransformerPluginV2GetConfiguration"/>  
	    <xsd:complexType name="WSTransformerPluginV2VariableDescriptor"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="variableName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="mandatory" type="xsd:boolean"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="true" name="contentTypesRegex" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="true" name="possibleValuesRegex" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginV2VariableDescriptor" type="tns:WSTransformerPluginV2VariableDescriptor"/>  
	    <xsd:complexType name="WSTransformerPluginV2Details"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="inputVariableDescriptors" type="tns:WSTransformerPluginV2VariableDescriptor"/>  
	        <xsd:element minOccurs="0" maxOccurs="unbounded" nillable="false" name="outputVariableDescriptors" type="tns:WSTransformerPluginV2VariableDescriptor"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="documentation" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="parametersSchema" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginV2Details" type="tns:WSTransformerPluginV2Details"/>  
	    <xsd:complexType name="WSGetTransformerPluginV2Details"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="jndiName" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="language" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformerPluginV2Details" type="tns:WSGetTransformerPluginV2Details"/>  
	    <xsd:complexType name="WSTransformerPluginV2sList"> 
	      <xsd:sequence> 
	        <xsd:element name="Item" minOccurs="0" maxOccurs="unbounded"> 
	          <xsd:complexType> 
	            <xsd:sequence> 
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="jndiName" type="xsd:string"/>  
	              <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="description" type="xsd:string"/> 
	            </xsd:sequence> 
	          </xsd:complexType> 
	        </xsd:element> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSTransformerPluginV2sList" type="tns:WSTransformerPluginV2sList"/>  
	    <!-- ***************************************************** Transformer 
	                Plugins V2 - Operations ******************************************************* -->  
	    <xsd:complexType name="WSGetTransformerPluginV2sList"> 
	      <xsd:annotation> 
	        <xsd:documentation>Returns the list of available Transformer Plugins in a WSTransformerPluginV2sList that provides their JNDI Name and Description in the requested language</xsd:documentation> 
	      </xsd:annotation>  
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="language" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetTransformerPluginV2sList" type="tns:WSGetTransformerPluginV2sList"/>  
	    <!-- ***************************************************** ROUTING ORDERS 
	                ******************************************************* -->  
	    <!-- Definitions -->  
	    <xsd:simpleType name="WSRoutingOrderV2Status"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="ACTIVE"/>  
	        <xsd:enumeration value="FAILED"/>  
	        <xsd:enumeration value="COMPLETED"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:complexType name="WSRoutingOrderV2PK"> 
	      <xsd:documentation>The primary key of a Routing Order made of its name and status (ACTIVE, FAILED, COMPLETED)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="name" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="status" type="tns:WSRoutingOrderV2Status"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2PK" type="tns:WSRoutingOrderV2PK"/>  
	    <xsd:complexType name="WSRoutingOrderV2"> 
	      <xsd:documentation>A routing Order name: its unique name status: the Routing Order status (ACTIVE, FAILED COMPLETED) timeCreated: the time in millis at which the Routing Order was created timeScheduled: the time in millis at which the Routing Order was scheduled for processing timeLastRunStarted: the time in millis at which this Routing Order last started execution timeLastRunCompleted: the time in millis at which this Routing Order last completed execution wsItemPK: the primary key of the Item routed serviceJNDI: the JNDI name of the service executed serviceParameters: additional parameters passed to the service for execution (example: the from field for an email) message: the message returned by the service after execution</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="name" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="status" type="tns:WSRoutingOrderV2Status"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeCreated" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeScheduled" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunStarted" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunCompleted" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsItemPK" type="tns:WSItemPK"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="serviceJNDI" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="serviceParameters" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="false" name="message" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="false" name="bindingUniverseName" type="xsd:string"/>  
	        <xsd:element minOccurs="0" maxOccurs="1" nillable="false" name="bindingUserToken" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2" type="tns:WSRoutingOrderV2"/>  
	    <xsd:complexType name="WSRoutingOrderV2PKArray"> 
	      <xsd:documentation>An Array of Routing Orders primary keys</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsRoutingOrder" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2PKArray" type="tns:WSRoutingOrderV2PKArray"/>  
	    <xsd:complexType name="WSRoutingOrderV2Array"> 
	      <xsd:documentation>An array of Routing Orders</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="unbounded" nillable="false" name="wsRoutingOrder" type="tns:WSRoutingOrderV2"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2Array" type="tns:WSRoutingOrderV2Array"/>  
	    <!-- Actions -->  
	    <xsd:complexType name="WSGetRoutingOrderV2"> 
	      <xsd:documentation>A message to retrieve a Routing Order</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsRoutingOrderPK" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingOrderV2" type="tns:WSGetRoutingOrderV2"/>  
	    <xsd:complexType name="WSExistsRoutingOrderV2"> 
	      <xsd:documentation>A message to check the existence of a Routing Order and retrive it if it exists</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsRoutingOrderPK" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExistsRoutingOrderV2" type="tns:WSExistsRoutingOrderV2"/>  
	    <xsd:complexType name="WSDeleteRoutingOrderV2"> 
	      <xsd:documentation>A message to delete a Routing Order</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsRoutingOrderPK" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSDeleteRoutingOrderV2" type="tns:WSDeleteRoutingOrderV2"/>  
	    <xsd:complexType name="WSRoutingOrderV2SearchCriteria"> 
	      <xsd:documentation>A message to search Routing Orders using criteria status: the Routing Order status (ACTIVE, FAILED COMPLETED) anyFieldContains: keyword(s) contained in any of the Routing Order field timeCreatedMin: the minimum time in millis at which the Routing Order was created timeCreatedMax: the maximum time in millis at which the Routing Order was created timeScheduledMin: the minimum time in millis at which the Routing Order was scheduled for processing timeScheduledMax: the maximum time in millis at which the Routing Order was scheduled for processing timeLastRunStartedMin: the minimum time in millis at which this Routing Order last started execution timeLastRunStartedMax: the maximum time in millis at which this Routing Order last started execution timeLastRunCompletedMin: the minimum time in millis at which this Routing Order last completed execution timeLastRunCompletedMax: the maximum time in millis at which this Routing Order last completed execution itemPKConceptContains: a regular expression on the Concept of the Item routed itemPKIDFieldsContain: a regular expression on the IDs joined by dots of the Item routed serviceJNDIContains: a regular expression on the JNDI name of the service executed serviceParametersContain: a regular expression on the additional parameters passed to the service for execution (example: the from field for an email) messageContain: a regular expression on the message returned by the service after execution</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="status" type="tns:WSRoutingOrderV2Status"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="anyFieldContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="nameContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeCreatedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeCreatedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeScheduledMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeScheduledMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunStartedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunStartedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunCompletedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunCompletedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="itemPKConceptContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="itemPKIDFieldsContain" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="serviceJNDIContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="serviceParametersContain" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="messageContain" type="xsd:string"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2SearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/>  
	    <xsd:complexType name="WSRoutingOrderV2SearchCriteriaWithPaging"> 
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="status" type="tns:WSRoutingOrderV2Status"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="anyFieldContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="nameContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeCreatedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeCreatedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeScheduledMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeScheduledMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunStartedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunStartedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunCompletedMin" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="timeLastRunCompletedMax" type="xsd:long"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="itemPKConceptContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="itemPKIDFieldsContain" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="serviceJNDIContains" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="serviceParametersContain" type="xsd:string"/>  
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="true" name="messageContain" type="xsd:string"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" nillable="false" name="skip" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="1" nillable="false" name="maxItems" type="xsd:int"/>  
	        <xsd:element maxOccurs="1" minOccurs="0" nillable="false" name="totalCountOnFirstResult" type="xsd:boolean"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingOrderV2SearchCriteriaWithPaging" type="tns:WSRoutingOrderV2SearchCriteriaWithPaging"/>  
	    <xsd:complexType name="WSGetRoutingOrderV2PKsByCriteria"> 
	      <xsd:documentation>A message to search Routing Orders primary keys using criteria</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingOrderV2PKsByCriteria" type="tns:WSGetRoutingOrderV2PKsByCriteria"/>  
	    <xsd:complexType name="WSGetRoutingOrderV2sByCriteria"> 
	      <xsd:documentation>A message to search Routing Orders using criteria</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsSearchCriteria" type="tns:WSRoutingOrderV2SearchCriteria"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingOrderV2sByCriteria" type="tns:WSGetRoutingOrderV2sByCriteria"/>  
	    <xsd:complexType name="WSGetRoutingOrderV2ByCriteriaWithPaging"> 
	      <xsd:sequence> 
	        <xsd:element maxOccurs="1" minOccurs="1" nillable="false" name="wsSearchCriteriaWithPaging" type="tns:WSRoutingOrderV2SearchCriteriaWithPaging"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSGetRoutingOrderV2ByCriteriaWithPaging" type="tns:WSGetRoutingOrderV2ByCriteriaWithPaging"/>  
	    <xsd:complexType name="WSExecuteRoutingOrderV2Synchronously"> 
	      <xsd:documentation>A message to execute a Routing Order synchronously.</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExecuteRoutingOrderV2Synchronously" type="tns:WSExecuteRoutingOrderV2Synchronously"/>  
	    <xsd:complexType name="WSExecuteRoutingOrderV2Asynchronously"> 
	      <xsd:documentation>A message to execute a Routing Order asynchronously</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="routingOrderV2PK" type="tns:WSRoutingOrderV2PK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSExecuteRoutingOrderV2Asynchronously" type="tns:WSExecuteRoutingOrderV2Asynchronously"/>  
	    <!-- ***************************************************** ROUTING ENGINE 
	                ******************************************************* -->  
	    <xsd:simpleType name="WSRoutingEngineV2Status"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="DEAD"/>  
	        <xsd:enumeration value="STOPPED"/>  
	        <xsd:enumeration value="SUSPENDED"/>  
	        <xsd:enumeration value="RUNNING"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:element name="WSRoutingEngineV2Status" type="tns:WSRoutingEngineV2Status"/>  
	    <xsd:complexType name="WSRouteItemV2"> 
	      <xsd:documentation>A message to submit an Item to the Routing Engine</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsItemPK" type="tns:WSItemPK"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRouteItemV2" type="tns:WSRouteItemV2"/>  
	    <xsd:simpleType name="WSRoutingEngineV2ActionCode"> 
	      <xsd:restriction base="xsd:NMTOKEN"> 
	        <xsd:enumeration value="START"/>  
	        <xsd:enumeration value="STOP"/>  
	        <xsd:enumeration value="SUSPEND"/>  
	        <xsd:enumeration value="RESUME"/>  
	        <xsd:enumeration value="STATUS"/> 
	      </xsd:restriction> 
	    </xsd:simpleType>  
	    <xsd:element name="WSRoutingEngineV2ActionCode" type="tns:WSRoutingEngineV2ActionCode"/>  
	    <xsd:complexType name="WSRoutingEngineV2Action"> 
	      <xsd:documentation>A message to execute an Action on the Routing Engine (START, STOP, SUSPEND, RESUME, STATUS)</xsd:documentation>
	      <xsd:sequence> 
	        <xsd:element minOccurs="1" maxOccurs="1" nillable="false" name="wsAction" type="tns:WSRoutingEngineV2ActionCode"/> 
	      </xsd:sequence> 
	    </xsd:complexType>  
	    <xsd:element name="WSRoutingEngineV2Action" type="tns:WSRoutingEngineV2Action"/> 
	  </xsd:schema>  
	</types>

	<!-- ***************************************************** M E S S A G E S ******************************************************* -->

	<!-- ****************** VARIOUS *********************** -->

	<message name="pingRequest">
		<part name="wsPing" element="tns:WSPing" />
	</message>
	<message name="pingResponse">
		<part name="dummy" element="tns:WSString" />
	</message>
	<message name="refreshCacheRequest">
		<part name="refreshCache" element="tns:WSRefreshCache" />
	</message>
	<message name="refreshCacheResponse">
		<part name="dummy" element="tns:WSString" />
	</message>
	<message name="logoutRequest">
		<part name="wsLogout" element="tns:WSLogout" />
	</message>
	<message name="logoutResponse">
		<part name="dummy" element="tns:WSString" />
	</message>


	<!-- ****************** COMPONENTS MANAGEMENT *********************** -->

	<message name="getComponentVersionRequest">
		<part name="wsGetComponentVersion" element="tns:WSGetComponentVersion" />
	</message>
	<message name="getComponentVersionResponse">
		<part name="wsVersion" element="tns:WSVersion" />
	</message>


	<!-- ****************** INITIALIZATION *********************** -->

	<message name="initMDMRequest">
		<part name="initData" element="tns:WSInitData" />
	</message>
	<message name="initMDMResponse">
		<part name="bytes" element="tns:WSInt" />
	</message>


	<!-- ****************** DATA MODEL *********************** -->
	<!-- <message name="getDataModelsRequest"> <part name="regexp" element="tns:WSRegexDataModels"/> 
		</message> <message name="getDataModelsResponse"> <part name="wsDataModels" 
		element="tns:WSDataModelArray"/> </message> -->

	<message name="getDataModelPKsRequest">
		<part name="regexp" element="tns:WSRegexDataModelPKs" />
	</message>
	<message name="getDataModelPKsResponse">
		<part name="wsDataModelPKs" element="tns:WSDataModelPKArray" />
	</message>

	<message name="getDataModelRequest">
		<part name="wsDataModelget" element="tns:WSGetDataModel" />
	</message>
	<message name="getDataModelResponse">
		<part name="wsDataModel" element="tns:WSDataModel" />
	</message>

	<message name="existsDataModelRequest">
		<part name="wsDataModelExists" element="tns:WSExistsDataModel" />
	</message>
	<message name="existsDataModelResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>
	<message name="putDataModelRequest">
		<part name="wsDataModel" element="tns:WSPutDataModel" />
	</message>
	<message name="putDataModelResponse">
		<part name="wsDataModelPK" element="tns:WSDataModelPK" />
	</message>

	<message name="deleteDataModelRequest">
		<part name="wsDeleteDataModel" element="tns:WSDeleteDataModel" />
	</message>
	<message name="deleteDataModelResponse">
		<part name="wsDataModelPK" element="tns:WSDataModelPK" />
	</message>

	<message name="checkSchemaRequest">
		<part name="wsSchema" element="tns:WSCheckSchema" />
	</message>
	<message name="checkSchemaResponse">
		<part name="wsErrors" element="tns:WSString" />
	</message>

	<message name="deleteBusinessConceptRequest">
		<part name="wsDeleteBusinessConcept" element="tns:WSDeleteBusinessConcept" />
	</message>
	<message name="deleteBusinessConceptResponse">
		<part name="wsBusinessConceptName" element="tns:WSString" />
	</message>

	<message name="getBusinessConceptsRequest">
		<part name="wsGetBusinessConcepts" element="tns:WSGetBusinessConcepts" />
	</message>
	<message name="getBusinessConceptsResponse">
		<part name="wsBusinessConceptsNames" element="tns:WSStringArray" />
	</message>

	<message name="putBusinessConceptRequest">
		<part name="wsPutBusinessConcept" element="tns:WSPutBusinessConcept" />
	</message>
	<message name="putBusinessConceptResponse">
		<part name="wsBusinessConceptSchema" element="tns:WSString" />
	</message>

	<message name="putBusinessConceptSchemaRequest">
		<part name="wsPutBusinessConceptSchema" element="tns:WSPutBusinessConceptSchema" />
	</message>
	<message name="putBusinessConceptSchemaResponse">
		<part name="wsBusinessConceptName" element="tns:WSString" />
	</message>

	<message name="getBusinessConceptKeyRequest">
		<part name="wsGetBusinessConceptKey" element="tns:WSGetBusinessConceptKey" />
	</message>
	<message name="getBusinessConceptKeyResponse">
		<part name="wsconceptKey" element="tns:WSConceptKey" />
	</message>
	<!-- ******************** DATA CLUSTER *********************** -->

	<message name="getDataClusterPKsRequest">
		<part name="regexp" element="tns:WSRegexDataClusterPKs" />
	</message>
	<message name="getDataClusterPKsResponse">
		<part name="wsDataClusterPKs" element="tns:WSDataClusterPKArray" />
	</message>
	<message name="getDataClusterRequest">
		<part name="wsDataClusterPK" element="tns:WSGetDataCluster" />
	</message>
	<message name="getDataClusterResponse">
		<part name="wsDataCluster" element="tns:WSDataCluster" />
	</message>

	<message name="existsDataClusterRequest">
		<part name="wsExistsDataCluster" element="tns:WSExistsDataCluster" />
	</message>
	<message name="existsDataClusterResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>
	<message name="existsDBDataClusterRequest">
		<part name="wsExistsDBDataCluster" element="tns:WSExistsDBDataCluster" />
	</message>
	<message name="existsDBDataClusterResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>
	<message name="putDataClusterRequest">
		<part name="wsDataCluster" element="tns:WSPutDataCluster" />
	</message>
	<message name="putDataClusterResponse">
		<part name="wsDataClusterPK" element="tns:WSDataClusterPK" />
	</message>
	<message name="putDBDataClusterRequest">
		<part name="wsDataCluster" element="tns:WSPutDBDataCluster" />
	</message>
	<message name="putDBDataClusterResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>
	<message name="deleteDataClusterRequest">
		<part name="wsDeleteDataCluster" element="tns:WSDeleteDataCluster" />
	</message>
	<message name="deleteDataClusterResponse">
		<part name="wsDataClusterPK" element="tns:WSDataClusterPK" />
	</message>

	<message name="getConceptsInDataClusterRequest">
		<part name="wsGetConceptsInDataCluster" element="tns:WSGetConceptsInDataCluster" />
	</message>
	<message name="getConceptsInDataClusterResponse">
		<part name="wsConcepts" element="tns:WSStringArray" />
	</message>

	<message name="getConceptsInDataClusterWithRevisionsRequest">
		<part name="wsGetConceptsInDataClusterWithRevisions" element="tns:WSGetConceptsInDataClusterWithRevisions" />
	</message>
	<message name="getConceptsInDataClusterWithRevisionsResponse">
		<part name="wsConceptRevisionMap" element="tns:WSConceptRevisionMap" />
	</message>
		
	<!-- ******************** B A C K G R O U N D J O B *********************** -->

	<message name="findBackgroundJobPKsRequest">
		<part name="status" element="tns:WSFindBackgroundJobPKs" />
	</message>
	<message name="findBackgroundJobPKsResponse">
		<part name="wsJobs" element="tns:WSBackgroundJobPKArray" />
	</message>
	<message name="putBackgroundJobRequest">
		<part name="wsPutBackgroundJob" element="tns:WSPutBackgroundJob" />
	</message>
	<message name="putBackgroundJobResponse">
		<part name="wsBackgroundJobPK" element="tns:WSBackgroundJobPK" />
	</message>
	<message name="getBackgroundJobRequest">
		<part name="wsGetBackgroundJob" element="tns:WSGetBackgroundJob" />
	</message>
	<message name="getBackgroundJobResponse">
		<part name="wsBackgroundJob" element="tns:WSBackgroundJob" />
	</message>
	<!-- ************************ VIEW *************************** -->

	<message name="getViewPKsRequest">
		<part name="regexp" element="tns:WSGetViewPKs" />
	</message>
	<message name="getViewPKsResponse">
		<part name="wsViewPKs" element="tns:WSViewPKArray" />
	</message>
	<message name="getViewRequest">
		<part name="wsViewPK" element="tns:WSGetView" />
	</message>
	<message name="getViewResponse">
		<part name="wsView" element="tns:WSView" />
	</message>

	<message name="existsViewRequest">
		<part name="wsViewPK" element="tns:WSExistsView" />
	</message>
	<message name="existsViewResponse">
		<part name="wsBooelan" element="tns:WSBoolean" />
	</message>
	<message name="putViewRequest">
		<part name="wsView" element="tns:WSPutView" />
	</message>
	<message name="putViewResponse">
		<part name="wsViewPK" element="tns:WSViewPK" />
	</message>
	<message name="deleteViewRequest">
		<part name="wsViewDel" element="tns:WSDeleteView" />
	</message>
	<message name="deleteViewResponse">
		<part name="wsViewPK" element="tns:WSViewPK" />
	</message>

	<!-- ************************ SEARCH *************************** -->

	<message name="getBusinessConceptValueRequest">
		<part name="wsGetBusinessConceptValue" element="tns:WSGetBusinessConceptValue" />
	</message>
	<message name="getBusinessConceptValueResponse">
		<part name="value" element="tns:WSString" />
	</message>
	<message name="getFullPathValuesRequest">
		<part name="wsGetFullPathValues" element="tns:WSGetFullPathValues" />
	</message>
	<message name="getFullPathValuesResponse">
		<part name="values" element="tns:WSStringArray" />
	</message>
	<message name="getItemRequest">
		<part name="wsGetItem" element="tns:WSGetItem" />
	</message>
	<message name="getItemResponse">
		<part name="wsItem" element="tns:WSItem" />
	</message>

	<message name="existsItemRequest">
		<part name="wsExistsItem" element="tns:WSExistsItem" />
	</message>
	<message name="existsItemResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>
	<message name="getItemsRequest">
		<part name="wsGetItems" element="tns:WSGetItems" />
	</message>
	<message name="getItemsResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>
	<message name="getItemsSortRequest">
		<part name="wsGetItemsSort" element="tns:WSGetItemsSort" />
	</message>
	<message name="getItemsSortResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>

	<message name="getItemPKsByCriteriaRequest">
		<part name="wsGetItemPKsByCriteria" element="tns:WSGetItemPKsByCriteria" />
	</message>
	<message name="getItemPKsByCriteriaResponse">
		<part name="wsItemPKsByCriteriaResponse" element="tns:WSItemPKsByCriteriaResponse" />
	</message>

	<message name="getItemPKsByFullCriteriaRequest">
		<part name="wsGetItemPKsByFullCriteria" element="tns:WSGetItemPKsByFullCriteria" />
	</message>
	<message name="getItemPKsByFullCriteriaResponse">
		<part name="wsItemPKsByFullCriteriaResponse" element="tns:WSItemPKsByCriteriaResponse" />
	</message>

	<message name="countItemsByCustomFKFiltersRequest">
		<part name="wsCountItemsByCustomFKFilters" element="tns:WSCountItemsByCustomFKFilters" />
	</message>
	<message name="countItemsByCustomFKFiltersResponse">
		<part name="wsCountItemsByCustomFKFiltersResponse" element="tns:WSString" />
	</message>

	<message name="getItemsByCustomFKFiltersRequest">
		<part name="wsGetItemsByCustomFKFilters" element="tns:WSGetItemsByCustomFKFilters" />
	</message>
	<message name="getItemsByCustomFKFiltersResponse">
		<part name="wsGetItemsByCustomFKFiltersResponse" element="tns:WSStringArray" />
	</message>
	<message name="viewSearchRequest">
		<part name="wsViewSearch" element="tns:WSViewSearch" />
	</message>
	<message name="viewSearchResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>
	<message name="xPathsSearchRequest">
		<part name="wsXPathsSearch" element="tns:WSXPathsSearch" />
	</message>
	<message name="xPathsSearchResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>
	<message name="getItemsPivotIndexRequest">
		<part name="wsGetItemsPivotIndex" element="tns:WSGetItemsPivotIndex" />
	</message>
	<message name="getItemsPivotIndexResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>
	<message name="getChildrenItemsRequest">
		<part name="wsGetChildrenItems" element="tns:WSGetChildrenItems" />
	</message>
	<message name="getChildrenItemsResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>
	<message name="countRequest">
		<part name="wsCount" element="tns:WSCount" />
	</message>
	<message name="countResponse">
		<part name="count" element="tns:WSString" />
	</message>
	<message name="quickSearchRequest">
		<part name="wsQuickSearch" element="tns:WSQuickSearch" />
	</message>
	<message name="quickSearchResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>

	<!-- ************************ PUT ITEM *************************** -->
	<message name="putItemRequest">
		<part name="wsPutItem" element="tns:WSPutItem" />
	</message>
	<message name="putItemResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>
	<message name="partialPutItemRequest">
		<part name="wsPartialPutItem" element="tns:WSPartialPutItem" />
	</message>
	<message name="partialPutItemResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>

	<message name="putItemArrayRequest">
		<part name="wsPutItemArray" element="tns:WSPutItemArray" />
	</message>
	<message name="putItemArrayResponse">
		<part name="wsItemPKArray" element="tns:WSItemPKArray" />
	</message>
	<message name="putItemWithReportRequest">
		<part name="wsPutItemWithReport" element="tns:WSPutItemWithReport" />
	</message>
	<message name="putItemWithReportResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>
	<message name="putItemWithCustomReportRequest">
		<part name="wsPutItemWithCustomReport" element="tns:WSPutItemWithCustomReport" />
	</message>
	<message name="putItemWithCustomReportResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>
	<message name="putItemWithReportArrayRequest">
		<part name="wsPutItemWithReportArray" element="tns:WSPutItemWithReportArray" />
	</message>
	<message name="putItemWithReportArrayResponse">
		<part name="wsItemPKArray" element="tns:WSItemPKArray" />
	</message>

	<message name="isItemModifiedByOtherRequest">
		<part name="wsItem" element="tns:WSIsItemModifiedByOther" />
	</message>
	<message name="isItemModifiedByOtherResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<!-- ************************ EXTRACT ITEMS *************************** -->
	<message name="extractUsingTransformerRequest">
		<part name="wsExtractUsingTransformer" element="tns:WSExtractUsingTransformer" />
	</message>
	<message name="extractUsingTransformerResponse">
		<part name="wsPipeline" element="tns:WSPipeline" />
	</message>
	<message name="extractUsingTransformerThruViewRequest">
		<part name="wsExtractUsingTransformerThruView" element="tns:WSExtractUsingTransformerThruView" />
	</message>
	<message name="extractUsingTransformerThruViewResponse">
		<part name="wsPipeline" element="tns:WSPipeline" />
	</message>


	<!-- ************************ DELETE ITEM *************************** -->
	<message name="deleteItemRequest">
		<part name="wsDeleteItem" element="tns:WSDeleteItem" />
	</message>
	<message name="deleteItemResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>

	<message name="deleteItemWithReportRequest">
		<part name="wsDeleteItem" element="tns:WSDeleteItemWithReport" />
	</message>
	<message name="deleteItemWithReportResponse">
		<part name="message" element="tns:WSString" />
	</message>

	<message name="deleteItemsRequest">
		<part name="wsDeleteItems" element="tns:WSDeleteItems" />
	</message>
	<message name="deleteItemsResponse">
		<part name="numItems" element="tns:WSInt" />
	</message>

	<message name="dropItemRequest">
		<part name="wsDropItem" element="tns:WSDropItem" />
	</message>
	<message name="dropItemResponse">
		<part name="wsDroppedItemPK" element="tns:WSDroppedItemPK" />
	</message>


	<!-- ************************ DIRECT QUERY *************************** -->
	<message name="runQueryRequest">
		<part name="wsRunQuery" element="tns:WSRunQuery" />
	</message>
	<message name="runQueryResponse">
		<part name="wsStringArray" element="tns:WSStringArray" />
	</message>


	<!-- ************************ CONNECTOR *************************** -->
	<message name="connectorInteractionRequest">
		<part name="wsConnectorInteraction" element="tns:WSConnectorInteraction" />
	</message>
	<message name="connectorInteractionResponse">
		<part name="wsConnectorInteractionResponse" element="tns:WSConnectorInteractionResponse" />
	</message>



	<!-- ************************ Services *************************** -->

	<message name="serviceActionRequest">
		<part name="wsServiceAction" element="tns:WSServiceAction" />
	</message>
	<message name="serviceActionResponse">
		<part name="statusString" element="tns:WSString" />
	</message>

	<message name="getServiceConfigurationRequest">
		<part name="wsGetConfiguration" element="tns:WSServiceGetConfiguration" />
	</message>
	<message name="getServiceConfigurationResponse">
		<part name="configuration" element="tns:WSString" />
	</message>

	<message name="putServiceConfigurationRequest">
		<part name="wsPutConfiguration" element="tns:WSServicePutConfiguration" />
	</message>
	<message name="putServiceConfigurationResponse">
		<part name="result" element="tns:WSString" />
	</message>

	<message name="getServicesListRequest">
		<part name="wsGetServicesList" element="tns:WSGetServicesList" />
	</message>
	<message name="getServicesListResponse">
		<part name="wsServicesList" element="tns:WSServicesList" />
	</message>

	<message name="getServiceDocumentRequest">
		<part name="serviceName" element="tns:WSString" />
	</message>
	<message name="getServiceDocumentResponse">
		<part name="result" element="tns:WSServiceGetDocument" />
	</message>	
	<!-- ************************ Stored Procedure *************************** -->

	<message name="getStoredProcedurePKsRequest">
		<part name="regex" element="tns:WSRegexStoredProcedure" />
	</message>
	<message name="getStoredProcedurePKsResponse">
		<part name="wsStoredProcedurePKArray" element="tns:WSStoredProcedurePKArray" />
	</message>

	<message name="getStoredProcedureRequest">
		<part name="wsGetStoredProcedure" element="tns:WSGetStoredProcedure" />
	</message>
	<message name="getStoredProcedureResponse">
		<part name="wsStoredProcedure" element="tns:WSStoredProcedure" />
	</message>

	<message name="existsStoredProcedureRequest">
		<part name="wsExistsStoredProcedure" element="tns:WSExistsStoredProcedure" />
	</message>
	<message name="existsStoredProcedureResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="putStoredProcedureRequest">
		<part name="wsStoredProcedure" element="tns:WSPutStoredProcedure" />
	</message>
	<message name="putStoredProcedureResponse">
		<part name="wsStoredProcedurePK" element="tns:WSStoredProcedurePK" />
	</message>

	<message name="deleteStoredProcedureRequest">
		<part name="wsStoredProcedureDelete" element="tns:WSDeleteStoredProcedure" />
	</message>
	<message name="deleteStoredProcedureResponse">
		<part name="wsStoredProcedurePK" element="tns:WSStoredProcedurePK" />
	</message>

	<message name="executeStoredProcedureRequest">
		<part name="wsExecuteStoredProcedure" element="tns:WSExecuteStoredProcedure" />
	</message>
	<message name="executeStoredProcedureResponse">
		<part name="results" element="tns:WSStringArray" />
	</message>


	<!-- ************************ Transformer *************************** -->

	<message name="getTransformerPKsRequest">
		<part name="regex" element="tns:WSGetTransformerPKs" />
	</message>
	<message name="getTransformerPKsResponse">
		<part name="wsTransformerPKArray" element="tns:WSTransformerPKArray" />
	</message>

	<message name="getTransformerRequest">
		<part name="wsGetTransformer" element="tns:WSGetTransformer" />
	</message>
	<message name="getTransformerResponse">
		<part name="wsTransformer" element="tns:WSTransformer" />
	</message>

	<message name="existsTransformerRequest">
		<part name="wsExistsTransformer" element="tns:WSExistsTransformer" />
	</message>
	<message name="existsTransformerResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="putTransformerRequest">
		<part name="wsTransformer" element="tns:WSPutTransformer" />
	</message>
	<message name="putTransformerResponse">
		<part name="wsTransformerPK" element="tns:WSTransformerPK" />
	</message>

	<message name="deleteTransformerRequest">
		<part name="wsTransformerDelete" element="tns:WSDeleteTransformer" />
	</message>
	<message name="deleteTransformerResponse">
		<part name="wsTransformerPK" element="tns:WSTransformerPK" />
	</message>

	<message name="processBytesUsingTransformerRequest">
		<part name="wsProcessBytesUsingTransformer" element="tns:WSProcessBytesUsingTransformer" />
	</message>
	<message name="processBytesUsingTransformerResponse">
		<part name="wsPipeline" element="tns:WSPipeline" />
	</message>

	<message name="processFileUsingTransformerRequest">
		<part name="wsProcessFileUsingTransformer" element="tns:WSProcessFileUsingTransformer" />
	</message>
	<message name="processFileUsingTransformerResponse">
		<part name="wsPipeline" element="tns:WSPipeline" />
	</message>

	<message name="processBytesUsingTransformerAsBackgroundJobRequest">
		<part name="wsProcessBytesUsingTransformerAsBackgroundJob"
			element="tns:WSProcessBytesUsingTransformerAsBackgroundJob" />
	</message>
	<message name="processBytesUsingTransformerAsBackgroundJobResponse">
		<part name="wsBackgroundJobPK" element="tns:WSBackgroundJobPK" />
	</message>

	<message name="processFileUsingTransformerAsBackgroundJobRequest">
		<part name="wsProcessFileUsingTransformerAsBackgroundJob"
			element="tns:WSProcessFileUsingTransformerAsBackgroundJob" />
	</message>
	<message name="processFileUsingTransformerAsBackgroundJobResponse">
		<part name="wsBackgroundJobPK" element="tns:WSBackgroundJobPK" />
	</message>



	<!-- ************************ Menu *************************** -->

	<message name="getMenuPKsRequest">
		<part name="regex" element="tns:WSGetMenuPKs" />
	</message>
	<message name="getMenuPKsResponse">
		<part name="wsMenuPKArray" element="tns:WSMenuPKArray" />
	</message>

	<message name="getMenuRequest">
		<part name="wsGetMenu" element="tns:WSGetMenu" />
	</message>
	<message name="getMenuResponse">
		<part name="wsMenu" element="tns:WSMenu" />
	</message>

	<message name="existsMenuRequest">
		<part name="wsExistsMenu" element="tns:WSExistsMenu" />
	</message>
	<message name="existsMenuResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="putMenuRequest">
		<part name="wsMenu" element="tns:WSPutMenu" />
	</message>
	<message name="putMenuResponse">
		<part name="wsMenuPK" element="tns:WSMenuPK" />
	</message>

	<message name="deleteMenuRequest">
		<part name="wsMenuDelete" element="tns:WSDeleteMenu" />
	</message>
	<message name="deleteMenuResponse">
		<part name="wsMenuPK" element="tns:WSMenuPK" />
	</message>


	<!-- ************************ Universe *************************** -->

	<message name="getCurrentUniverseRequest">
		<part name="wsGetCurrentUniverse" element="tns:WSGetCurrentUniverse" />
	</message>
	<message name="getCurrentUniverseResponse">
		<part name="wsUniverse" element="tns:WSUniverse" />
	</message>

	<!-- ************************ Dropped Item *************************** -->

	<message name="recoverDroppedItemRequest">
		<part name="wsRecoverDroppedItem" element="tns:WSRecoverDroppedItem" />
	</message>
	<message name="recoverDroppedItemResponse">
		<part name="wsItemPK" element="tns:WSItemPK" />
	</message>

	<message name="findAllDroppedItemsPKsRequest">
		<part name="regex" element="tns:WSFindAllDroppedItemsPKs" />
	</message>
	<message name="findAllDroppedItemsPKsResponse">
		<part name="wsDroppedItemPKArray" element="tns:WSDroppedItemPKArray" />
	</message>

	<message name="loadDroppedItemRequest">
		<part name="wsLoadDroppedItem" element="tns:WSLoadDroppedItem" />
	</message>
	<message name="loadDroppedItemResponse">
		<part name="wsDroppedItem" element="tns:WSDroppedItem" />
	</message>

	<message name="removeDroppedItemRequest">
		<part name="wsRemoveDroppedItem" element="tns:WSRemoveDroppedItem" />
	</message>
	<message name="removeDroppedItemResponse">
		<part name="wsDroppedItemPK" element="tns:WSDroppedItemPK" />
	</message>

	<message name="getMDMConfigurationRequest">
	</message>
	<message name="getMDMConfigurationResponse">
		<part name="wsMDMConfig" element="tns:WSMDMConfig"></part>
	</message>
	<message name="checkServiceConfigurationRequest">
		<part name="serviceName" element="tns:WSCheckServiceConfigRequest"></part>
	</message>
	<message name="checkServiceConfigurationResponse">
		<part name="result" element="tns:WSCheckServiceConfigResponse"></part>
	</message>
	<!-- ************************ RoutingRule *************************** -->

	<message name="getRoutingRulePKsRequest">
		<part name="regexp" element="tns:WSGetRoutingRulePKs" />
	</message>
	<message name="getRoutingRulePKsResponse">
		<part name="wsRoutingRulePKs" element="tns:WSRoutingRulePKArray" />
	</message>

	<message name="getRoutingRuleRequest">
		<part name="wsRoutingRulePK" element="tns:WSGetRoutingRule" />
	</message>
	<message name="getRoutingRuleResponse">
		<part name="wsRoutingRule" element="tns:WSRoutingRule" />
	</message>

	<message name="existsRoutingRuleRequest">
		<part name="wsExistsRoutingRule" element="tns:WSExistsRoutingRule" />
	</message>
	<message name="existsRoutingRuleResponse">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="putRoutingRuleRequest">
		<part name="wsRoutingRule" element="tns:WSPutRoutingRule" />
	</message>
	<message name="putRoutingRuleResponse">
		<part name="wsRoutingRulePK" element="tns:WSRoutingRulePK" />
	</message>

	<message name="deleteRoutingRuleRequest">
		<part name="wsRoutingRuleDel" element="tns:WSDeleteRoutingRule" />
	</message>
	<message name="deleteRoutingRuleResponse">
		<part name="wsRoutingRulePK" element="tns:WSRoutingRulePK" />
	</message>
	<!-- ************************ TransformerV2 *************************** -->

	<message name="getTransformerV2PKsRequest">
		<part name="regex" element="tns:WSGetTransformerV2PKs" />
	</message>
	<message name="getTransformerV2PKsResponse">
		<part name="wsTransformerV2PKArray" element="tns:WSTransformerV2PKArray" />
	</message>

	<message name="getTransformerV2Request">
		<part name="wsGetTransformerV2" element="tns:WSGetTransformerV2" />
	</message>
	<message name="getTransformerV2Response">
		<part name="wsTransformerV2" element="tns:WSTransformerV2" />
	</message>

	<message name="existsTransformerV2Request">
		<part name="wsExistsTransformerV2" element="tns:WSExistsTransformerV2" />
	</message>
	<message name="existsTransformerV2Response">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="putTransformerV2Request">
		<part name="wsTransformerV2" element="tns:WSPutTransformerV2" />
	</message>
	<message name="putTransformerV2Response">
		<part name="wsTransformerV2PK" element="tns:WSTransformerV2PK" />
	</message>

	<message name="deleteTransformerV2Request">
		<part name="wsDeleteTransformerV2" element="tns:WSDeleteTransformerV2" />
	</message>
	<message name="deleteTransformerV2Response">
		<part name="wsTransformerV2PK" element="tns:WSTransformerV2PK" />
	</message>

	<message name="executeTransformerV2Request">
		<part name="wsExecuteTransformerV2" element="tns:WSExecuteTransformerV2" />
	</message>
	<message name="executeTransformerV2Response">
		<part name="wsTransformerContext" element="tns:WSTransformerContext" />
	</message>

	<message name="executeTransformerV2AsJobRequest">
		<part name="wsExecuteTransformerV2AsJob" element="tns:WSExecuteTransformerV2AsJob" />
	</message>
	<message name="executeTransformerV2AsJobResponse">
		<part name="wsBackgroundJobPK" element="tns:WSBackgroundJobPK" />
	</message>

	<message name="extractThroughTransformerV2Request">
		<part name="wsExtractThroughTransformerV2" element="tns:WSExtractThroughTransformerV2" />
	</message>
	<message name="extractThroughTransformerV2Response">
		<part name="wsTransformerContext" element="tns:WSTransformerContext" />
	</message>

	<!-- ************************ TransformerPluginV2s *************************** -->

	<message name="existsTransformerPluginV2Request">
		<part name="wsExistsTransformerPluginV2" element="tns:WSExistsTransformerPluginV2" />
	</message>
	<message name="existsTransformerPluginV2Response">
		<part name="wsBoolean" element="tns:WSBoolean" />
	</message>

	<message name="getTransformerPluginV2ConfigurationRequest">
		<part name="wsGetConfiguration" element="tns:WSTransformerPluginV2GetConfiguration" />
	</message>
	<message name="getTransformerPluginV2ConfigurationResponse">
		<part name="configuration" element="tns:WSString" />
	</message>

	<message name="putTransformerPluginV2ConfigurationRequest">
		<part name="wsPutConfiguration" element="tns:WSTransformerPluginV2PutConfiguration" />
	</message>
	<message name="putTransformerPluginV2ConfigurationResponse">
		<part name="result" element="tns:WSString" />
	</message>

	<message name="getTransformerPluginV2DetailsRequest">
		<part name="wsGetTransformerPluginV2Details" element="tns:WSGetTransformerPluginV2Details" />
	</message>
	<message name="getTransformerPluginV2DetailsResponse">
		<part name="result" element="tns:WSTransformerPluginV2Details" />
	</message>

	<message name="getTransformerPluginV2sListRequest">
		<part name="wsGetTransformerPluginV2sList" element="tns:WSGetTransformerPluginV2sList" />
	</message>
	<message name="getTransformerPluginV2sListResponse">
		<part name="wsTransformerPluginV2sList" element="tns:WSTransformerPluginV2sList" />
	</message>

	<!-- ************************ Routing Order V2 *************************** -->

	<message name="getRoutingOrderV2Request">
		<part name="wsGetRoutingOrderV2" element="tns:WSGetRoutingOrderV2" />
	</message>
	<message name="getRoutingOrderV2Response">
		<part name="wsRoutingOrder" element="tns:WSRoutingOrderV2" />
	</message>

	<message name="existsRoutingOrderV2Request">
		<part name="wsExistsRoutingOrder" element="tns:WSExistsRoutingOrderV2" />
	</message>
	<message name="existsRoutingOrderV2Response">
		<part name="wsRoutingOrder" element="tns:WSRoutingOrderV2" />
	</message>

	<message name="deleteRoutingOrderV2Request">
		<part name="wsDeleteRoutingOrder" element="tns:WSDeleteRoutingOrderV2" />
	</message>
	<message name="deleteRoutingOrderV2Response">
		<part name="wsRoutingOrderPK" element="tns:WSRoutingOrderV2PK" />
	</message>

	<message name="executeRoutingOrderV2AsynchronouslyRequest">
		<part name="wsExecuteRoutingOrderAsynchronously" element="tns:WSExecuteRoutingOrderV2Asynchronously" />
	</message>
	<message name="executeRoutingOrderV2AsynchronouslyResponse">
		<part name="wsRoutingOrderPK" element="tns:WSRoutingOrderV2PK" />
	</message>

	<message name="executeRoutingOrderV2SynchronouslyRequest">
		<part name="wsExecuteRoutingOrderSynchronously" element="tns:WSExecuteRoutingOrderV2Synchronously" />
	</message>
	<message name="executeRoutingOrderV2SynchronouslyResponse">
		<part name="result" element="tns:WSString" />
	</message>

	<message name="getRoutingOrderV2PKsByCriteriaRequest">
		<part name="wsGetRoutingOrderV2PKsByCriteria" element="tns:WSGetRoutingOrderV2PKsByCriteria" />
	</message>
	<message name="getRoutingOrderV2PKsByCriteriaResponse">
		<part name="wsRoutingOrderPKArray" element="tns:WSRoutingOrderV2PKArray" />
	</message>

	<message name="getRoutingOrderV2sByCriteriaRequest">
		<part name="wsGetRoutingOrderV2sByCriteria" element="tns:WSGetRoutingOrderV2sByCriteria" />
	</message>
	<message name="getRoutingOrderV2sByCriteriaResponse">
		<part name="wsRoutingOrderArray" element="tns:WSRoutingOrderV2Array" />
	</message>

	<message name="getRoutingOrderV2ByCriteriaWithPagingRequest">
		<part name="wsGetRoutingOrderV2ByCriteriaWithPaging" element="tns:WSGetRoutingOrderV2ByCriteriaWithPaging" />
	</message>
	<message name="getRoutingOrderV2ByCriteriaWithPagingResponse">
		<part name="wsRoutingOrderArray" element="tns:WSRoutingOrderV2Array" />
	</message>


	<!-- ************************ Routing Engine V2 *************************** -->

	<message name="routeItemV2Request">
		<part name="wsRouteItem" element="tns:WSRouteItemV2" />
	</message>
	<message name="routeItemV2Response">
		<part name="wsRoutingRulePKs" element="tns:WSRoutingRulePKArray" />
	</message>

	<message name="routingEngineV2ActionRequest">
		<part name="wsRoutingEngineAction" element="tns:WSRoutingEngineV2Action" />
	</message>
	<message name="routingEngineV2ActionResponse">
		<part name="wsRoutingEngineStatus" element="tns:WSRoutingEngineV2Status" />
	</message>

	<message name="getMDMJobRequest">
		<part name="mdmJobRequest" element="tns:WSMDMNULL"></part>
	</message>
	<message name="getMDMJobResponse">
		<part name="mdmJobResponse" element="tns:WSMDMJobArray"></part>
	</message>

	<message name="putMDMJobRequest">
		<part name="putMDMJobRequest" element="tns:WSPUTMDMJob"></part>
	</message>
	<message name="putMDMJobResponse">
		<part name="putMDMJobResponse" element="tns:WSBoolean"></part>
	</message>

	<message name="deleteMDMJobRequest">
		<part name="deleteMDMJobRequest" element="tns:WSDELMDMJob"></part>
	</message>
	<message name="deleteMDMJobResponse">
		<part name="deleteMDMJobResponse" element="tns:WSBoolean"></part>
	</message>
	<message name="getMDMCategoryRequest">
		<part name="wsCategoryDataRequest" element="tns:WSCategoryData" />
	</message>
	<message name="getMDMCategoryResponse">
		<part name="wsCategoryDataResponse" element="tns:WSCategoryData" />
	</message>
	<message name="getAutoIncrementRequest">
		<part name="wsAutoIncrementRequest" element="tns:WSAutoIncrement" />
	</message>
	<message name="getAutoIncrementResponse">
		<part name="wsAutoIncrementResponse" element="tns:WSAutoIncrement" />
	</message>
	<!-- ***************************************************** P O R T ******************************************************* -->


	<portType name="XtentisPort">


		<!-- ****************** COMPONENTS MANAGEMENT *********************** -->

		<operation name="getComponentVersion">
			<wsdl:documentation>Retrieves the version of a MDM core component (only support the "DataManager" component)</wsdl:documentation>
			<input message="tns:getComponentVersionRequest" />
			<output message="tns:getComponentVersionResponse" />
		</operation>
		<!-- ****************** VARIOUS *********************** -->

		<operation name="ping">
		    <wsdl:documentation>A simple ping to which the server respond to by a pong. Used to check if the server is up</wsdl:documentation>
			<input message="tns:pingRequest" />
			<output message="tns:pingResponse" />
		</operation>
		<operation name="refreshCache">
		    <wsdl:documentation>Refresh the cache data of MDM objects and items</wsdl:documentation>
			<input message="tns:refreshCacheRequest" />
			<output message="tns:refreshCacheResponse" />
		</operation>
		<operation name="logout">
		    <wsdl:documentation>Logs out an user by clearing the JAAS caches.This operation must be invoked after a role is changed on an user.</wsdl:documentation>
			<input message="tns:logoutRequest" />
			<output message="tns:logoutResponse" />
		</operation>

		<!-- ****************** INITIALIZATION *********************** -->

		<operation name="initMDM">
		    <wsdl:documentation>DEPRECATED trigger MDM migration task(s) manually</wsdl:documentation>
			<input message="tns:initMDMRequest" />
			<output message="tns:initMDMResponse" />
		</operation>

		<!-- ****************** DATA MODEL *********************** -->

		<operation name="getDataModelPKs">
		    <wsdl:documentation>Lists the Data Models using a regular expression on their names</wsdl:documentation>
			<input message="tns:getDataModelPKsRequest" />
			<output message="tns:getDataModelPKsResponse" />
		</operation>
		<operation name="existsDataModel">
		    <wsdl:documentation>Check the existence of a Data Model and returns it if it exists</wsdl:documentation>
			<input message="tns:existsDataModelRequest" />
			<output message="tns:existsDataModelResponse" />
		</operation>
		<operation name="getDataModel">
		    <wsdl:documentation>Retrieve a Data Model</wsdl:documentation>
			<input message="tns:getDataModelRequest" />
			<output message="tns:getDataModelResponse" />
		</operation>
		<operation name="putDataModel">
		    <wsdl:documentation>Store/overwrite a Data Model</wsdl:documentation>
			<input message="tns:putDataModelRequest" />
			<output message="tns:putDataModelResponse" />
		</operation>
		<operation name="deleteDataModel">
		    <wsdl:documentation>Delete a Data Model</wsdl:documentation>
			<input message="tns:deleteDataModelRequest" />
			<output message="tns:deleteDataModelResponse" />
		</operation>
		<operation name="checkSchema">
		    <wsdl:documentation>Check the validity of an (XSD) schema for a Data Model</wsdl:documentation>
			<input message="tns:checkSchemaRequest" />
			<output message="tns:checkSchemaResponse" />
		</operation>
		<operation name="deleteBusinessConcept">
		    <wsdl:documentation>Delete a Concept from a Data Model</wsdl:documentation>
			<input message="tns:deleteBusinessConceptRequest" />
			<output message="tns:deleteBusinessConceptResponse" />
		</operation>
		<operation name="putBusinessConceptSchema">
		    <wsdl:documentation>Create a Concept in Data Model through inserting its (XSD) schema</wsdl:documentation>
			<input message="tns:putBusinessConceptSchemaRequest" />
			<output message="tns:putBusinessConceptSchemaResponse" />
		</operation>
		<operation name="getBusinessConcepts">
		    <wsdl:documentation>Retrieve the list of Concepts in a Data Model</wsdl:documentation>
			<input message="tns:getBusinessConceptsRequest" />
			<output message="tns:getBusinessConceptsResponse" />
		</operation>
		<operation name="putBusinessConcept">
		    <wsdl:documentation>Create a Concept</wsdl:documentation>
			<input message="tns:putBusinessConceptRequest" />
			<output message="tns:putBusinessConceptResponse" />
		</operation>
		<operation name="getBusinessConceptKey">
		    <wsdl:documentation>Retrieve the elements constitutive of the key of a Concept</wsdl:documentation>
			<input message="tns:getBusinessConceptKeyRequest" />
			<output message="tns:getBusinessConceptKeyResponse" />
		</operation>


		<!-- ***************D A T A C L U S T E R ********************** -->

		<operation name="getDataClusterPKs">
		    <wsdl:documentation>Retrieve the list of Data Clusters using a regular expression on their names</wsdl:documentation>
			<input message="tns:getDataClusterPKsRequest" />
			<output message="tns:getDataClusterPKsResponse" />
		</operation>
		<operation name="getDataCluster">
		   <wsdl:documentation>Retrieve a Data Cluster</wsdl:documentation>
			<input message="tns:getDataClusterRequest" />
			<output message="tns:getDataClusterResponse" />
		</operation>
		<operation name="existsDataCluster">
		    <wsdl:documentation>Check the existence of a Data Cluster and return it if it exists</wsdl:documentation>
			<input message="tns:existsDataClusterRequest" />
			<output message="tns:existsDataClusterResponse" />
		</operation>
		<operation name="existsDBDataCluster">
		    <wsdl:documentation>Check the existence of a Data Cluster on the database layer, also the Data Cluster revision can be specified</wsdl:documentation>
			<input message="tns:existsDBDataClusterRequest" />
			<output message="tns:existsDBDataClusterResponse" />
		</operation>
		<operation name="putDataCluster">
		    <wsdl:documentation>Create/Update a Data Cluster</wsdl:documentation>
			<input message="tns:putDataClusterRequest" />
			<output message="tns:putDataClusterResponse" />
		</operation>
		<operation name="putDBDataCluster">
		    <wsdl:documentation>Create/Update a Data Cluster on the database layer, also the Data Cluster revision can be specified</wsdl:documentation>
			<input message="tns:putDBDataClusterRequest" />
			<output message="tns:putDBDataClusterResponse" />
		</operation>
		<operation name="deleteDataCluster">
		    <wsdl:documentation>Delete a Data Cluster with its items</wsdl:documentation>
			<input message="tns:deleteDataClusterRequest" />
			<output message="tns:deleteDataClusterResponse" />
		</operation>
		<operation name="getConceptsInDataCluster">
		    <wsdl:documentation>Retrieve a list of all the Concepts stored in a Data Cluster</wsdl:documentation>
			<input message="tns:getConceptsInDataClusterRequest" />
			<output message="tns:getConceptsInDataClusterResponse" />
		</operation>
		<operation name="getConceptsInDataClusterWithRevisions">
		    <wsdl:documentation>Retrieve the list of all Concepts stored in a Data Cluster for a specific revision</wsdl:documentation>
			<input message="tns:getConceptsInDataClusterWithRevisionsRequest" />
			<output message="tns:getConceptsInDataClusterWithRevisionsResponse" />
		</operation>


		<!-- ********************* VIEW ************************ -->

		<operation name="getViewPKs">
		    <wsdl:documentation>Retrieve a list of Views using a regular expression on their names</wsdl:documentation>
			<input message="tns:getViewPKsRequest" />
			<output message="tns:getViewPKsResponse" />
		</operation>
		<operation name="getView">
		    <wsdl:documentation>Retrieve a View</wsdl:documentation>
			<input message="tns:getViewRequest" />
			<output message="tns:getViewResponse" />
		</operation>
		<operation name="existsView">
		    <wsdl:documentation>Check the existence of a View and return it if it exists</wsdl:documentation>
			<input message="tns:existsViewRequest" />
			<output message="tns:existsViewResponse" />
		</operation>
		<operation name="putView">
		    <wsdl:documentation>Create/Update a View</wsdl:documentation>
			<input message="tns:putViewRequest" />
			<output message="tns:putViewResponse" />
		</operation>
		<operation name="deleteView">
		    <wsdl:documentation>Delete a View</wsdl:documentation>
			<input message="tns:deleteViewRequest" />
			<output message="tns:deleteViewResponse" />
		</operation>

		<!-- ********************* SEARCH ************************ -->

		<operation name="getBusinessConceptValue">
		    <wsdl:documentation>DEPRECATED Retrieve the serialized value of an business concept item</wsdl:documentation>
			<input message="tns:getBusinessConceptValueRequest" />
			<output message="tns:getBusinessConceptValueResponse" />
		</operation>
		<operation name="getFullPathValues">
		    <wsdl:documentation>Retrieve the values for a list of xPaths</wsdl:documentation>
			<input message="tns:getFullPathValuesRequest" />
			<output message="tns:getFullPathValuesResponse" />
		</operation>
		<operation name="getItem">
		    <wsdl:documentation>Retrieve an Item</wsdl:documentation>
			<input message="tns:getItemRequest" />
			<output message="tns:getItemResponse" />
		</operation>
		<operation name="existsItem">
		    <wsdl:documentation>Check the existence of an Item and return it if it exists</wsdl:documentation>
			<input message="tns:existsItemRequest" />
			<output message="tns:existsItemResponse" />
		</operation>
		<operation name="getItems">
		    <wsdl:documentation>Retrieve a list or sublist of items for a designated concept using search criteria</wsdl:documentation>
			<input message="tns:getItemsRequest" />
			<output message="tns:getItemsResponse" />
		</operation>
		<operation name="getItemsSort">
		    <wsdl:documentation>Retrieve a list or sublist of items for a designated concept using search criteria with a specified order</wsdl:documentation>
			<input message="tns:getItemsSortRequest" />
			<output message="tns:getItemsSortResponse" />
		</operation>
		<operation name="getItemPKsByCriteria">
		    <wsdl:documentation>Retrieve a list or sublist of Item primary keys for a designated concept using search criteria</wsdl:documentation>
			<input message="tns:getItemPKsByCriteriaRequest" />
			<output message="tns:getItemPKsByCriteriaResponse" />
		</operation>
		<operation name="getItemPKsByFullCriteria">
		    <wsdl:documentation>Retrieve a list or sublist of Item primary keys for a designated concept using search criteria with the capability to use a full-text search</wsdl:documentation>
			<input message="tns:getItemPKsByFullCriteriaRequest" />
			<output message="tns:getItemPKsByFullCriteriaResponse" />
		</operation>
		<operation name="countItemsByCustomFKFilters">
		    <wsdl:documentation>Count the total number of an item search result with a designated custom FK filter</wsdl:documentation>
			<input message="tns:countItemsByCustomFKFiltersRequest" />
			<output message="tns:countItemsByCustomFKFiltersResponse" />
		</operation>
		<operation name="getItemsByCustomFKFilters">
		    <wsdl:documentation>Retrieve a list or sublist of items for a designated custom FK filter</wsdl:documentation>
			<input message="tns:getItemsByCustomFKFiltersRequest" />
			<output message="tns:getItemsByCustomFKFiltersResponse" />
		</operation>
		<operation name="viewSearch">
		    <wsdl:documentation>Retrieve a list of values specified using a View</wsdl:documentation>
			<input message="tns:viewSearchRequest" />
			<output message="tns:viewSearchResponse" />
		</operation>
		<operation name="xPathsSearch">
		    <wsdl:documentation>Retrieve a list or sublist of xml documents specified using xPaths and optional conditions on the Items content</wsdl:documentation>
			<input message="tns:xPathsSearchRequest" />
			<output message="tns:xPathsSearchResponse" />
		</operation>
		<operation name="getItemsPivotIndex">
		    <wsdl:documentation>DEPRECATED Get Items hierarchical tree according to pivots</wsdl:documentation>
			<input message="tns:getItemsPivotIndexRequest" />
			<output message="tns:getItemsPivotIndexResponse" />
		</operation>
		<operation name="getChildrenItems">
		    <wsdl:documentation>DEPRECATED Retrieve a list of items which contained by its parent FK node</wsdl:documentation>
			<input message="tns:getChildrenItemsRequest" />
			<output message="tns:getChildrenItemsResponse" />
		</operation>
		<operation name="count">
		    <wsdl:documentation>Count values for a particular xPath using optional conditions on the Items content</wsdl:documentation>
			<input message="tns:countRequest" />
			<output message="tns:countResponse" />
		</operation>
		<operation name="quickSearch">
		    <wsdl:documentation>Retrieve Items through a view using optional conditions and keywords on the Items content</wsdl:documentation>
			<input message="tns:quickSearchRequest" />
			<output message="tns:quickSearchResponse" />
		</operation>


		<operation name="putItem">
		    <wsdl:documentation>Create/Update an Item</wsdl:documentation>
			<input message="tns:putItemRequest" />
			<output message="tns:putItemResponse" />
		</operation>

		<operation name="partialPutItem">
		    <wsdl:documentation>Update an Item partially through an xml fragment</wsdl:documentation>
			<input message="tns:partialPutItemRequest" />
			<output message="tns:partialPutItemResponse" />
		</operation>
		<operation name="putItemArray">
		    <wsdl:documentation>Create/overwrite a list of Items</wsdl:documentation>
			<input message="tns:putItemArrayRequest" />
			<output message="tns:putItemArrayResponse" />
		</operation>
		<operation name="putItemWithReport">
		    <wsdl:documentation>Create/overwrite an Item, also generate the relevant UpdateReport</wsdl:documentation>
			<input message="tns:putItemWithReportRequest" />
			<output message="tns:putItemWithReportResponse" />
		</operation>
		<operation name="putItemWithCustomReport">
		    <wsdl:documentation>Create/overwrite an Item, also generate the relevant UpdateReport with the capability to customize the attributes within the UpdateReport</wsdl:documentation>
			<input message="tns:putItemWithCustomReportRequest" />
			<output message="tns:putItemWithCustomReportResponse" />
		</operation>
		<operation name="putItemWithReportArray">
		    <wsdl:documentation>Create/overwrite a list of Items, also generate the relevant UpdateReports</wsdl:documentation>
			<input message="tns:putItemWithReportArrayRequest" />
			<output message="tns:putItemWithReportArrayResponse" />
		</operation>
		<operation name="extractUsingTransformer">
		    <wsdl:documentation>NOT SUPPORTED Extract an Item using its key and return the result after having it processed through a Transformer</wsdl:documentation>
			<input message="tns:extractUsingTransformerRequest" />
			<output message="tns:extractUsingTransformerResponse" />
		</operation>
		<operation name="extractUsingTransformerThruView">
		    <wsdl:documentation>Extract results through a view and transform them using a transformer</wsdl:documentation>
			<input message="tns:extractUsingTransformerThruViewRequest" />
			<output message="tns:extractUsingTransformerThruViewResponse" />
		</operation>

		<operation name="isItemModifiedByOther">
		    <wsdl:documentation>Detect the target item has been modified by the other users or not</wsdl:documentation>
			<input message="tns:isItemModifiedByOtherRequest" />
			<output message="tns:isItemModifiedByOtherResponse" />
		</operation>

		<!-- ********************* DELETE ITEMS ************************ -->

		<operation name="deleteItem">
		    <wsdl:documentation>Delete an existing Item</wsdl:documentation>
			<input message="tns:deleteItemRequest" />
			<output message="tns:deleteItemResponse" />
		</operation>

		<operation name="deleteItemWithReport">
		    <wsdl:documentation>Delete an existing Item, also generate the relevant UpdateReport</wsdl:documentation>
			<input message="tns:deleteItemWithReportRequest" />
			<output message="tns:deleteItemWithReportResponse" />
		</operation>

		<operation name="deleteItems">
		    <wsdl:documentation>Delete a list of existing Items</wsdl:documentation>
			<input message="tns:deleteItemsRequest" />
			<output message="tns:deleteItemsResponse" />
		</operation>

		<operation name="dropItem">
		    <wsdl:documentation>Send an existing Item to the recycle bin</wsdl:documentation>
			<input message="tns:dropItemRequest" />
			<output message="tns:dropItemResponse" />
		</operation>

		<!-- ********************* DIRECT QUERY ************************ -->

		<operation name="runQuery">
		    <wsdl:documentation>Directly execute a query on a database and return the result</wsdl:documentation>
			<input message="tns:runQueryRequest" />
			<output message="tns:runQueryResponse" />
		</operation>

		<!-- ********************* CONNECTOR ************************ -->

		<operation name="connectorInteraction">
		    <wsdl:documentation>Interact with a Connector: start, stop, get status, etc...</wsdl:documentation>
			<input message="tns:connectorInteractionRequest" />
			<output message="tns:connectorInteractionResponse" />
		</operation>


		<!-- ********************* SERVICES ************************ -->

		<operation name="serviceAction">
		    <wsdl:documentation>Interact with a Service: start, stop, get status, execute....</wsdl:documentation>
			<input message="tns:serviceActionRequest" />
			<output message="tns:serviceActionResponse" />
		</operation>
		<operation name="getServiceConfiguration">
		    <wsdl:documentation>Retrieve the configuration of a Service</wsdl:documentation>
			<input message="tns:getServiceConfigurationRequest" />
			<output message="tns:getServiceConfigurationResponse" />
		</operation>
		<operation name="putServiceConfiguration">
		    <wsdl:documentation>Store the configuration of a Service</wsdl:documentation>
			<input message="tns:putServiceConfigurationRequest" />
			<output message="tns:putServiceConfigurationResponse" />
		</operation>
		<operation name="getServicesList">
		    <wsdl:documentation>Retrieve the list of available Services on the server</wsdl:documentation>
			<input message="tns:getServicesListRequest" />
			<output message="tns:getServicesListResponse" />
		</operation>
		<operation name="getServiceDocument">
		    <wsdl:documentation>Retrieve the documentation of a Service</wsdl:documentation>
			<input message="tns:getServiceDocumentRequest" />
			<output message="tns:getServiceDocumentResponse" />
		</operation>			
		<!-- ********************* STORED PROCEDURE ************************ -->

		<operation name="getStoredProcedure">
		    <wsdl:documentation>Retrieve an existing Stored Procedure</wsdl:documentation>
			<input message="tns:getStoredProcedureRequest" />
			<output message="tns:getStoredProcedureResponse" />
		</operation>
		<operation name="existsStoredProcedure">
		    <wsdl:documentation>Check the existence of a Stored Procedure and return it if it exists</wsdl:documentation>
			<input message="tns:existsStoredProcedureRequest" />
			<output message="tns:existsStoredProcedureResponse" />
		</operation>
		<operation name="getStoredProcedurePKs">
		    <wsdl:documentation>Retrieve a list of Stored Procedures using a regular expression on their names</wsdl:documentation>
			<input message="tns:getStoredProcedurePKsRequest" />
			<output message="tns:getStoredProcedurePKsResponse" />
		</operation>
		<operation name="putStoredProcedure">
		    <wsdl:documentation>Create/Update a Stored Procedure</wsdl:documentation>
			<input message="tns:putStoredProcedureRequest" />
			<output message="tns:putStoredProcedureResponse" />
		</operation>
		<operation name="deleteStoredProcedure">
		    <wsdl:documentation>Delete an existing Stored Procedure</wsdl:documentation>
			<input message="tns:deleteStoredProcedureRequest" />
			<output message="tns:deleteStoredProcedureResponse" />
		</operation>
		<operation name="executeStoredProcedure">
		    <wsdl:documentation>Execute a Stored Procedure with optional parameters and return the result</wsdl:documentation>
			<input message="tns:executeStoredProcedureRequest" />
			<output message="tns:executeStoredProcedureResponse" />
		</operation>


		<!-- ********************* TRANSFORMER ************************ -->

		<operation name="getTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:getTransformerRequest" />
			<output message="tns:getTransformerResponse" />
		</operation>
		<operation name="existsTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:existsTransformerRequest" />
			<output message="tns:existsTransformerResponse" />
		</operation>
		<operation name="getTransformerPKs">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:getTransformerPKsRequest" />
			<output message="tns:getTransformerPKsResponse" />
		</operation>
		<operation name="putTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:putTransformerRequest" />
			<output message="tns:putTransformerResponse" />
		</operation>
		<operation name="deleteTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:deleteTransformerRequest" />
			<output message="tns:deleteTransformerResponse" />
		</operation>
		<operation name="processBytesUsingTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:processBytesUsingTransformerRequest" />
			<output message="tns:processBytesUsingTransformerResponse" />
		</operation>
		<operation name="processFileUsingTransformer">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:processFileUsingTransformerRequest" />
			<output message="tns:processFileUsingTransformerResponse" />
		</operation>
		<operation name="processBytesUsingTransformerAsBackgroundJob">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:processBytesUsingTransformerAsBackgroundJobRequest" />
			<output message="tns:processBytesUsingTransformerAsBackgroundJobResponse" />
		</operation>
		<operation name="processFileUsingTransformerAsBackgroundJob">
		    <wsdl:documentation>DEPRECATED - use the TransformerV2 version</wsdl:documentation>
			<input message="tns:processFileUsingTransformerAsBackgroundJobRequest" />
			<output message="tns:processFileUsingTransformerAsBackgroundJobResponse" />
		</operation>


		<!-- ********************* Menu ************************ -->

		<operation name="getMenu">
		    <wsdl:documentation>Retrieve a Menu</wsdl:documentation>
			<input message="tns:getMenuRequest" />
			<output message="tns:getMenuResponse" />
		</operation>
		<operation name="existsMenu">
		    <wsdl:documentation>Check the existence of a Menu and return the boolean value</wsdl:documentation>
			<input message="tns:existsMenuRequest" />
			<output message="tns:existsMenuResponse" />
		</operation>
		<operation name="getMenuPKs">
		    <wsdl:documentation>Retrieve a list of Menus using a regular expression on their names</wsdl:documentation>
			<input message="tns:getMenuPKsRequest" />
			<output message="tns:getMenuPKsResponse" />
		</operation>
		<operation name="putMenu">
		    <wsdl:documentation>Create/Update a Menu</wsdl:documentation>
			<input message="tns:putMenuRequest" />
			<output message="tns:putMenuResponse" />
		</operation>
		<operation name="deleteMenu">
		    <wsdl:documentation>Delete an existing Menu</wsdl:documentation>
			<input message="tns:deleteMenuRequest" />
			<output message="tns:deleteMenuResponse" />
		</operation>

		<!-- *************** B A C K G R O U N D J O B ********************** -->

		<operation name="findBackgroundJobPKs">
		    <wsdl:documentation>Retrieve a list of Background Jobs using a regular expression of their ids</wsdl:documentation>
			<input message="tns:findBackgroundJobPKsRequest" />
			<output message="tns:findBackgroundJobPKsResponse" />
		</operation>
		<operation name="putBackgroundJob">
		    <wsdl:documentation>Create/Update a Background Job</wsdl:documentation>
			<input message="tns:putBackgroundJobRequest" />
			<output message="tns:putBackgroundJobResponse" />
		</operation>
		<operation name="getBackgroundJob">
		    <wsdl:documentation>Retrieve an existing BackGround Job</wsdl:documentation>
			<input message="tns:getBackgroundJobRequest" />
			<output message="tns:getBackgroundJobResponse" />
		</operation>
		<!-- ********************* Universe ************************ -->

		<operation name="getCurrentUniverse">
		    <wsdl:documentation>Retrieve an Universe of the current login user</wsdl:documentation>
			<input message="tns:getCurrentUniverseRequest" />
			<output message="tns:getCurrentUniverseResponse" />
		</operation>


		<!-- ********************* Dropped Item ************************ -->

		<operation name="recoverDroppedItem">
		    <wsdl:documentation>Recover an dropped item from item's recycle bin</wsdl:documentation>
			<input message="tns:recoverDroppedItemRequest" />
			<output message="tns:recoverDroppedItemResponse" />
		</operation>
		<operation name="findAllDroppedItemsPKs">
		    <wsdl:documentation>Find all dropped items in the recycle bin</wsdl:documentation>
			<input message="tns:findAllDroppedItemsPKsRequest" />
			<output message="tns:findAllDroppedItemsPKsResponse" />
		</operation>
		<operation name="loadDroppedItem">
		    <wsdl:documentation>Load a dropped item from the recycle bin</wsdl:documentation>
			<input message="tns:loadDroppedItemRequest" />
			<output message="tns:loadDroppedItemResponse" />
		</operation>
		<operation name="removeDroppedItem">
		    <wsdl:documentation>Remove an dropped item from the recycle bin</wsdl:documentation>
			<input message="tns:removeDroppedItemRequest" />
			<output message="tns:removeDroppedItemResponse" />
		</operation>

		<operation name="getMDMConfiguration">
		    <wsdl:documentation>Retrieve a subset of the MDM configuration instance</wsdl:documentation>
			<input message="tns:getMDMConfigurationRequest" />
			<output message="tns:getMDMConfigurationResponse"></output>
		</operation>
		<operation name="checkServiceConfiguration">
		    <wsdl:documentation>Check the configuration correction of a MDM service</wsdl:documentation>
			<input message="tns:checkServiceConfigurationRequest" />
			<output message="tns:checkServiceConfigurationResponse"></output>
		</operation>
		<!-- ********************* ROUTING RULES ************************ -->

		<operation name="getRoutingRulePKs">
		    <wsdl:documentation>Retrieve a list of Routing Rules using a regular expression on their name</wsdl:documentation>
			<input message="tns:getRoutingRulePKsRequest" />
			<output message="tns:getRoutingRulePKsResponse" />
		</operation>
		<operation name="getRoutingRule">
		    <wsdl:documentation>Retrieve an existing Routing Rule</wsdl:documentation>
			<input message="tns:getRoutingRuleRequest" />
			<output message="tns:getRoutingRuleResponse" />
		</operation>
		<operation name="existsRoutingRule">
		    <wsdl:documentation>Check the existence of a Routing Rule</wsdl:documentation>
			<input message="tns:existsRoutingRuleRequest" />
			<output message="tns:existsRoutingRuleResponse" />
		</operation>
		<operation name="putRoutingRule">
		    <wsdl:documentation>Create/Update a Routing Rule</wsdl:documentation>
			<input message="tns:putRoutingRuleRequest" />
			<output message="tns:putRoutingRuleResponse" />
		</operation>
		<operation name="deleteRoutingRule">
		    <wsdl:documentation>Delete an existing Routing Rule</wsdl:documentation>
			<input message="tns:deleteRoutingRuleRequest" />
			<output message="tns:deleteRoutingRuleResponse" />
		</operation>
		<!-- ********************* TRANSFORMER V2 ************************ -->

		<operation name="getTransformerV2">
		    <wsdl:documentation>Retrieve a Transformer</wsdl:documentation>
			<input message="tns:getTransformerV2Request" />
			<output message="tns:getTransformerV2Response" />
		</operation>
		<operation name="existsTransformerV2">
		    <wsdl:documentation>Check the existence of a Transformer</wsdl:documentation>
			<input message="tns:existsTransformerV2Request" />
			<output message="tns:existsTransformerV2Response" />
		</operation>
		<operation name="getTransformerV2PKs">
		    <wsdl:documentation>Retrieve a list of Transformers using a regular expression on their names</wsdl:documentation>
			<input message="tns:getTransformerV2PKsRequest" />
			<output message="tns:getTransformerV2PKsResponse" />
		</operation>
		<operation name="putTransformerV2">
		    <wsdl:documentation>Create/Update a Transformer</wsdl:documentation>
			<input message="tns:putTransformerV2Request" />
			<output message="tns:putTransformerV2Response" />
		</operation>
		<operation name="deleteTransformerV2">
		    <wsdl:documentation>Delete an existing Transformer</wsdl:documentation>
			<input message="tns:deleteTransformerV2Request" />
			<output message="tns:deleteTransformerV2Response" />
		</operation>
		<operation name="executeTransformerV2">
		    <wsdl:documentation>Execute a Transformer pipeline process</wsdl:documentation>
			<input message="tns:executeTransformerV2Request" />
			<output message="tns:executeTransformerV2Response" />
		</operation>
		<operation name="executeTransformerV2AsJob">
		    <wsdl:documentation>Execute a Transformer pipeline process in background</wsdl:documentation>
			<input message="tns:executeTransformerV2AsJobRequest" />
			<output message="tns:executeTransformerV2AsJobResponse" />
		</operation>
		<operation name="extractThroughTransformerV2">
		    <wsdl:documentation>Extract data from a Transformer, the return value will be mapped to the _DEFAULT_ variable</wsdl:documentation>
			<input message="tns:extractThroughTransformerV2Request" />
			<output message="tns:extractThroughTransformerV2Response" />
		</operation>


		<!-- ********************* TRANSFORMER PLUGIN V2 ************************ -->

		<operation name="existsTransformerPluginV2">
		    <wsdl:documentation>Check the exsitence of a Transformer Plugin</wsdl:documentation>
			<input message="tns:existsTransformerPluginV2Request" />
			<output message="tns:existsTransformerPluginV2Response" />
		</operation>
		<operation name="getTransformerPluginV2Configuration">
		    <wsdl:documentation>Retrieve the configuration of a Transformer Plugin</wsdl:documentation>
			<input message="tns:getTransformerPluginV2ConfigurationRequest" />
			<output message="tns:getTransformerPluginV2ConfigurationResponse" />
		</operation>
		<operation name="putTransformerPluginV2Configuration">
		    <wsdl:documentation>Store the configuration of a Transformer Plugin</wsdl:documentation>
			<input message="tns:putTransformerPluginV2ConfigurationRequest" />
			<output message="tns:putTransformerPluginV2ConfigurationResponse" />
		</operation>
		<operation name="getTransformerPluginV2Details">
		    <wsdl:documentation>Retrieve the descriptive information of a Transformer Plugin, including input descriptors, output descriptors, parameter schema, plugin description and documentation</wsdl:documentation>
			<input message="tns:getTransformerPluginV2DetailsRequest" />
			<output message="tns:getTransformerPluginV2DetailsResponse" />
		</operation>
		<operation name="getTransformerPluginV2sList">
		    <wsdl:documentation>Retrieve a list of Transformer Plugins</wsdl:documentation>
			<input message="tns:getTransformerPluginV2sListRequest" />
			<output message="tns:getTransformerPluginV2sListResponse" />
		</operation>
		<!-- *************** R O U T I N G O R D E R S V 2 ********************** -->

		<operation name="getRoutingOrderV2">
		    <wsdl:documentation>Retrieve a Routing Order</wsdl:documentation>
			<input message="tns:getRoutingOrderV2Request" />
			<output message="tns:getRoutingOrderV2Response" />
		</operation>
		<operation name="existsRoutingOrderV2">
		    <wsdl:documentation>Check the existence of a Routing Order</wsdl:documentation>
			<input message="tns:existsRoutingOrderV2Request" />
			<output message="tns:existsRoutingOrderV2Response" />
		</operation>
		<operation name="deleteRoutingOrderV2">
		    <wsdl:documentation>Delete an existing Routing Order</wsdl:documentation>
			<input message="tns:deleteRoutingOrderV2Request" />
			<output message="tns:deleteRoutingOrderV2Response" />
		</operation>
		<operation name="executeRoutingOrderV2Asynchronously">
		    <wsdl:documentation>Execute a Routing Order asynchronously</wsdl:documentation>
			<input message="tns:executeRoutingOrderV2AsynchronouslyRequest" />
			<output message="tns:executeRoutingOrderV2AsynchronouslyResponse" />
		</operation>
		<operation name="executeRoutingOrderV2Synchronously">
		    <wsdl:documentation>Execute a Routing Order set synchronously</wsdl:documentation>
			<input message="tns:executeRoutingOrderV2SynchronouslyRequest" />
			<output message="tns:executeRoutingOrderV2SynchronouslyResponse" />
		</operation>
		<operation name="getRoutingOrderV2PKsByCriteria">
		    <wsdl:documentation>Retrieve a list of Routing Order primary keys using criteria on their content</wsdl:documentation>
			<input message="tns:getRoutingOrderV2PKsByCriteriaRequest" />
			<output message="tns:getRoutingOrderV2PKsByCriteriaResponse" />
		</operation>
		<operation name="getRoutingOrderV2sByCriteria">
		    <wsdl:documentation>Retrieve a list of Routing Order objects using criteria on their content</wsdl:documentation>
			<input message="tns:getRoutingOrderV2sByCriteriaRequest" />
			<output message="tns:getRoutingOrderV2sByCriteriaResponse" />
		</operation>
		<operation name="getRoutingOrderV2ByCriteriaWithPaging">
		    <wsdl:documentation>Retrieve a list or sublist of Routing Order objects using criteria on their content with an certain size</wsdl:documentation>
			<input message="tns:getRoutingOrderV2ByCriteriaWithPagingRequest" />
			<output message="tns:getRoutingOrderV2ByCriteriaWithPagingResponse" />
		</operation>

		<!-- *************** R O U T I N G E N G I N E V 2 ********************** -->

		<operation name="routeItemV2">
		    <wsdl:documentation>Send an Item for routing to the Subscription Engine</wsdl:documentation>
			<input message="tns:routeItemV2Request" />
			<output message="tns:routeItemV2Response" />
		</operation>
		<operation name="routingEngineV2Action">
		    <wsdl:documentation>Perform an action on the Subscription Engine: Start, Stop, Suspend, Resume,.....</wsdl:documentation>
			<input message="tns:routingEngineV2ActionRequest" />
			<output message="tns:routingEngineV2ActionResponse" />
		</operation>

		<operation name="getMDMJob">
		    <wsdl:documentation>Retrieve a list of deployed DI jobs on MDM server</wsdl:documentation>
			<input message="tns:getMDMJobRequest" />
			<output message="tns:getMDMJobResponse" />
		</operation>
		<operation name="putMDMJob">
		    <wsdl:documentation>DEPRECATED don't maintain the deployed job list on MDM xml DB</wsdl:documentation>
			<input message="tns:putMDMJobRequest" />
			<output message="tns:putMDMJobResponse" />
		</operation>
		<operation name="deleteMDMJob">
		    <wsdl:documentation>DEPRECATED don't maintain the deployed job list on MDM xml DB</wsdl:documentation>
			<input message="tns:deleteMDMJobRequest" />
			<output message="tns:deleteMDMJobResponse" />
		</operation>

		<operation name="getMDMCategory">
		    <wsdl:documentation>Retrieve the persistented category information for MDM Studio</wsdl:documentation>
			<input message="tns:getMDMCategoryRequest" />
			<output message="tns:getMDMCategoryResponse"></output>
		</operation>
		<operation name="getAutoIncrement">
		    <wsdl:documentation>Retrieve the AutoIncrement information from MDM server</wsdl:documentation>
			<input message="tns:getAutoIncrementRequest" />
			<output message="tns:getAutoIncrementResponse"></output>
		</operation>
	</portType>




	<!-- ***************************************************** B I N D I N G 
		******************************************************* -->

	<binding type="tns:XtentisPort" name="XtentisBinding">
		<soap:binding style="document"
			transport="http://schemas.xmlsoap.org/soap/http" />


		<!-- ****************** COMPONENTS MANAGEMENT *********************** -->

		<operation name="getComponentVersion">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ****************** VARIOUS *********************** -->

		<operation name="ping">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="refreshCache">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="logout">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<!-- ****************** INITIALIZATION *********************** -->

		<operation name="initMDM">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ****************** DATA MODEL *********************** -->

		<!-- <operation name="getDataModels"> <soap:operation style="document"/> 
			<input><soap:body use="literal"/></input> <output><soap:body use="literal"/></output> 
			</operation> -->
		<operation name="getDataModelPKs">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getDataModel">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsDataModel">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putDataModel">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteDataModel">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="checkSchema">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteBusinessConcept">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getBusinessConcepts">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putBusinessConcept">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putBusinessConceptSchema">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getBusinessConceptKey">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ***************D A T A C L U S T E R ********************** -->

		<operation name="getDataClusterPKs">
			<soap:operation style="document" />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsDBDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putDBDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getConceptsInDataCluster">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getConceptsInDataClusterWithRevisions">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* VIEW ************************ -->

		<operation name="getViewPKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getView">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsView">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putView">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteView">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* SEARCH ************************ -->

		<operation name="getBusinessConceptValue">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getFullPathValues">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItems">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItemsSort">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItemPKsByCriteria">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItemPKsByFullCriteria">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="countItemsByCustomFKFilters">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItemsByCustomFKFilters">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="viewSearch">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="xPathsSearch">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getItemsPivotIndex">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getChildrenItems">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="count">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="quickSearch">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* PUT ITEM ************************ -->

		<operation name="putItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="partialPutItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putItemArray">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putItemWithReportArray">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="putItemWithReport">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putItemWithCustomReport">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="isItemModifiedByOther">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* EXTRACT ITEMS ************************ -->
		<operation name="extractUsingTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="extractUsingTransformerThruView">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* DELETE ITEMS ************************ -->

		<operation name="deleteItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="deleteItemWithReport">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="deleteItems">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="dropItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* TEST: GET INCOMPLETE ITEMS ************************ -->
		<!-- <operation name="getIncompleteItems"> <soap:operation/> <input><soap:body 
			use="literal"/></input> <output><soap:body use="literal"/></output> </operation> -->

		<!-- ********************* DIRECT QUERY ************************ -->

		<operation name="runQuery">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* CONNECTOR ************************ -->

		<operation name="connectorInteraction">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* SERVICES ************************ -->

		<operation name="serviceAction">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getServiceConfiguration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putServiceConfiguration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getServicesList">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getServiceDocument">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>		
		<!-- ********************* STORED PROCEDURES ************************ -->

		<operation name="getStoredProcedure">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsStoredProcedure">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getStoredProcedurePKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putStoredProcedure">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteStoredProcedure">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="executeStoredProcedure">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* TRANSFORMER ************************ -->

		<operation name="getTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getTransformerPKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="processBytesUsingTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="processFileUsingTransformer">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="processBytesUsingTransformerAsBackgroundJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="processFileUsingTransformerAsBackgroundJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>



		<!-- ********************* Menu ************************ -->

		<operation name="getMenu">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsMenu">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getMenuPKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putMenu">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteMenu">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* Background Jobs ************************ -->

		<operation name="findBackgroundJobPKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getBackgroundJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putBackgroundJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<!-- ********************* Universe ************************ -->

		<operation name="getCurrentUniverse">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* Dropped Item ************************ -->
		<operation name="recoverDroppedItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="findAllDroppedItemsPKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="loadDroppedItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="removeDroppedItem">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getMDMConfiguration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="checkServiceConfiguration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<!-- ********************* ROUTING RULE ************************ -->

		<operation name="getRoutingRulePKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getRoutingRule">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsRoutingRule">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putRoutingRule">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteRoutingRule">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* TRANSFORMERV2 ************************ -->

		<operation name="getTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getTransformerV2PKs">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="executeTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="executeTransformerV2AsJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="extractThroughTransformerV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* TRANSFORMER PLUGIN V2 ************************ -->

		<operation name="existsTransformerPluginV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getTransformerPluginV2Configuration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="putTransformerPluginV2Configuration">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getTransformerPluginV2Details">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getTransformerPluginV2sList">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<!-- ********************* Routing Order V2 ************************ -->

		<operation name="getRoutingOrderV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="existsRoutingOrderV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="deleteRoutingOrderV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="executeRoutingOrderV2Asynchronously">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="executeRoutingOrderV2Synchronously">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getRoutingOrderV2PKsByCriteria">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getRoutingOrderV2sByCriteria">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getRoutingOrderV2ByCriteriaWithPaging">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>


		<!-- ********************* Routing Engine V2 ************************ -->

		<operation name="routeItemV2">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="routingEngineV2Action">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="getMDMJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="putMDMJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="deleteMDMJob">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>

		<operation name="getMDMCategory">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
		<operation name="getAutoIncrement">
			<soap:operation />
			<input>
				<soap:body use="literal" />
			</input>
			<output>
				<soap:body use="literal" />
			</output>
		</operation>
	</binding>


	<service name="XtentisService">
		<port binding="tns:XtentisBinding" name="XtentisPort">
			<soap:address location="http://localhost:8080/talend/TalendPort" />
		</port>
	</service>

</definitions>